<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Laispace - 来思碑]]></title>
  <subtitle><![CDATA[天酬勤笨先飞，乐观进取。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://laispace.github.io/"/>
  <updated>2014-12-18T13:22:05.986Z</updated>
  <id>http://laispace.github.io/</id>
  
  <author>
    <name><![CDATA[赖小赖]]></name>
    <email><![CDATA[laixiaolai@foxmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 碎片]]></title>
    <link href="http://laispace.github.io/2014/12/JavaScript%20%E7%A2%8E%E7%89%87/"/>
    <id>http://laispace.github.io/2014/12/JavaScript 碎片/</id>
    <published>2014-12-18T06:29:22.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>Object.defineProperty</p>
<pre><code>  <span class="keyword">var</span> A = {};
  <span class="built_in">Object</span>.defineProperty(A, <span class="string">'attrName'</span>, {
      set: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>{ 
          <span class="keyword">this</span>.__attrName__ = val; 
          <span class="built_in">console</span>.log(<span class="string">'A.attrName 被设置为: '</span>, val);
      },
      get: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{ 
          <span class="built_in">console</span>.log(<span class="string">'A.attrName 被获取到: '</span>, <span class="keyword">this</span>.__attrName__);
          <span class="keyword">return</span> <span class="keyword">this</span>.__attrName__; }
      });
  });    
</code></pre></li>
</ul>
]]></content>
    
    
      <category term="javascript" scheme="http://laispace.github.io/tags/javascript/"/>
    
      <category term="Javascript" scheme="http://laispace.github.io/categories/Javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动 Web 开发技巧]]></title>
    <link href="http://laispace.github.io/2014/12/%E7%A7%BB%E5%8A%A8%20Web%20%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://laispace.github.io/2014/12/移动 Web 开发技巧/</id>
    <published>2014-12-18T06:29:22.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Fiddler_篇">Fiddler 篇</h2>
<ul>
<li>使用Fiddler 快速 bugfix 的办法</li>
</ul>
<p>线上出一个小问题时, 定位到具体某一个文件比如 online.js<br>使用 Fiddler 将这个文件保存为 offline.js 到本地, 并设置 AutoResponder 将这个线上文件 online.js 的请求映射到 offline.js<br>接着就开始改动, 这样还没拉代码就先定位并解决问题了, 轻快~</p>
<ul>
<li>调试 iOS 端真机环境页面</li>
</ul>
<p>用 Chrome 模拟器并不能百分百模拟真机.</p>
<p>用 Fiddler 只能进行抓包调试, 对 UI 调试比较无力吧.</p>
<p>用 Weinre 远程调试在 PC 上成功, 但映射到 iOS 上时毫无反应,<br>不知道是不是因为同时启用了 Weinre 代理服务器和 Fiddler 代理服务器.</p>
<p>想自用一个在外网的机子搭建 Weinre 代理服务器(这样就不需要 PC 和 iOS 都在同一个局域网下), 但是内网 ssh 连接不上…内网这么多限制, 真是麻烦.</p>
<p>用 Fiddler 开启代理, iOS 接入 PC 所在的网络并设置代理为 Fiddler 服务器, 用 Mac 连接 iPhone, 使用 Safari 调试. 这个目前看来, 是最爽的了.</p>
]]></content>
    
    
      <category term="移动开发" scheme="http://laispace.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="Tips" scheme="http://laispace.github.io/categories/Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Web worker 的简单使用]]></title>
    <link href="http://laispace.github.io/2014/11/Web-worker-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://laispace.github.io/2014/11/Web-worker-的简单使用/</id>
    <published>2014-11-29T06:06:34.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Main-js">Main.js</h1>
<p>   注意在 chrome 下  worker 不能正常加载，需要在服务器环境下</p>
<pre><code>    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'Worker.js'</span>);

    <span class="comment">// 给 worker 发送消息</span>
    worker.postMessage(<span class="string">'Hi, I am a message from Main'</span>);

    <span class="comment">// 监听来自 worker 的消息</span>
    worker.onmessage  = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
        <span class="built_in">console</span>.log(e);
        <span class="built_in">console</span>.log(<span class="string">'Main had receive a message: '</span>, e.data);

        <span class="comment">// 接收 worker 传回的指令</span>
        <span class="keyword">if</span> (e.data.command) {
            <span class="built_in">eval</span>(<span class="string">'('</span> + e.data.command + <span class="string">')'</span>)
        }
    };

    <span class="comment">// 中止 worker</span>
    <span class="comment">// 立即杀死 worker</span>
    <span class="comment">// worker.terminate();</span>
</code></pre><h1 id="Worker-js">Worker.js</h1>
<pre><code>    <span class="attribute">console.log('Worker</span>: <span class="string">I am working!');</span>

<span class="javascript">    <span class="comment">// 发送消息给主线程</span>
    postMessage(<span class="string">'Hi, I am a message from Worker!'</span>);

    <span class="comment">// 监听主线程传来的消息</span>
    onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
        <span class="built_in">console</span>.log(e);
        <span class="built_in">console</span>.log(<span class="string">'Worker had receive a message: '</span>, e.data);
    };


    <span class="comment">// 注意： 通常来说，后台线程 – 包括 worker – 无法操作 DOM。</span>
    <span class="comment">// 如果后台线程需要修改 DOM，那么它应该将消息发送给它的创建者，让创建者来完成这些操作。</span>
    <span class="comment">// document.write('I will not be executed :(');  =&gt; 报错：alert is not defined</span>


    <span class="comment">//  所以为了操作 DOM, 可以通过传递命令的方式来让主线程来执行</span>
    postMessage({
        command: <span class="string">"document.write('hello I am from Worker')"</span>
    });    

    <span class="comment">// 除了在 Main.js 杀死线程，也可以自己杀死自己</span>
    <span class="comment">// self.close();  </span></span>
</code></pre>]]></content>
    
    
      <category term="worker" scheme="http://laispace.github.io/tags/worker/"/>
    
      <category term="HTML5" scheme="http://laispace.github.io/categories/HTML5/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用字符集和编码格式]]></title>
    <link href="http://laispace.github.io/2014/11/%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
    <id>http://laispace.github.io/2014/11/常用字符集和编码格式/</id>
    <published>2014-11-29T03:25:42.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用字符集和编码">常用字符集和编码</h1>
<ul>
<li>ASCII 美国信息交换标准代码</li>
</ul>
<p>编码规则： 7位表示一个字符，共128个字符</p>
<p>缺点：只能显示26个拉丁字母、阿拉伯数字和英文标点符号</p>
<ul>
<li>EASCII 欧洲扩展字符集</li>
</ul>
<p>编码规则：8位表示一个字符，共256个字符</p>
<p>缺点：虽解决了部分西欧语言的字符显示问题，但对其他更多的语言依然无力</p>
<ul>
<li>GB2312/GB2312-80 等中文字符集</li>
</ul>
<p>编码规则：把127号的字符取消掉（即EASCII），两个大于128的字符连在一起表示一个汉字，高字节从 0xA1 到 0xF7, 低字节从 0xA1 到 0xFE</p>
<ul>
<li>GBK 中文字符集</li>
</ul>
<p>微软对 GB2312-80 进行扩充后制定了 GBK 编码。</p>
<ul>
<li>Unicode 统一字符集</li>
</ul>
<p>包含超过十万个字符，让电脑能够解析世界上数十种语言。</p>
<p>编码规则：使用4个字节的数字来表达字母、符号、文字。</p>
<p>Unicode 指的是字符集，而 UTF-32, UTF-16, UTF-8 则说的是编码方案。</p>
<ul>
<li>UTF-32 </li>
</ul>
<p>编码规则：用上述 Unicode 的4字节的数字来表达字母、符号、文字</p>
<ul>
<li>UTF-16</li>
</ul>
<p>编码规则：</p>
<pre><code>若字符编码 U 小于 0x10000, 也就是小于十进制的 65535，则使用2个字节表示；

若字符编码 U 大于 0x10000, 也就是大于十进制的 65535，则使用4个字节表示。
</code></pre><ul>
<li>UTF-8 </li>
</ul>
<p>是针对对 Unicode 的可变长度字符编码，可表示 Unicode 中任何字符，且编码中第一个字节与 ASCII 兼容。</p>
<p>编码规则是使用1到4个字节为每个字符编码：</p>
<pre><code><span class="number">128</span>个 US-ASCII 字符只需用<span class="number">1</span>个字节编码，从 U+<span class="number">0000</span> 到 U+<span class="number">007F</span>

带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文等，则使用第<span class="number">2</span>个字节编码，从 U+<span class="number">0080</span> 到 U+<span class="number">07F</span>F

其他基本多文中平面中的字符则使用<span class="number">3</span>个字节编码

其他极少辅助平面中的字符则使用<span class="number">4</span>个字节编码
</code></pre>]]></content>
    
    
      <category term="Tools" scheme="http://laispace.github.io/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】ES6 Generators（4）并发篇]]></title>
    <link href="http://laispace.github.io/2014/09/%E3%80%90%E8%AF%91%E3%80%91ES6%20Generators%EF%BC%884%EF%BC%89%E5%B9%B6%E5%8F%91%E7%AF%87/"/>
    <id>http://laispace.github.io/2014/09/【译】ES6 Generators（4）并发篇/</id>
    <published>2014-09-30T10:45:45.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>注意：这篇文章没翻译完，可以先看<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">原文</a></p>
<blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>我们最好的主题是探索前沿的东西，接下来的概念可能会听起来有点懵，但一想到在未来这些东西会大派用场，想想都有点小激动呢！</p>
<p>这篇文章的主题受到 <a href="http://github.com/swannodette" target="_blank" rel="external">David Nolen</a> <a href="http://twitter.com/swannodette" target="_blank" rel="external">@swannodette</a> 的鼓舞，他写了介绍 CSP 的一些文章：</p>
<ul>
<li><a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/" target="_blank" rel="external">Communicating Sequential Processes</a></li>
<li><a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/" target="_blank" rel="external">ES6 Generators Deliver Go Style Concurrency</a></li>
<li><a href="http://swannodette.github.io/2013/07/31/extracting-processes/" target="_blank" rel="external">Extracting Processes</a></li>
</ul>
<p>当然，你也可以继续阅读这篇文章，听我娓娓道来并发式生成器的介绍。</p>
<p>我尝试了 Go 语言风格的 CSP API 的实现。当然比我更聪明的同行可能会看到我在这个探索中所遗漏的地方，我会持续不断地探索和尝试，并坚持和你们分享我所发现的东西。</p>
<h1 id="了解_CSP_(Communicating_Sequential_Processes)">了解 CSP (Communicating Sequential Processes)</h1>
<p>CSP 这个概念来自 Tony Hoare的《<a href="http://www.usingcsp.com/" target="_blank" rel="external">Communicating Sequential Processes</a>》一书。</p>
<p>这是一个非常深的计算机理论，我并不打算以太多晦涩难懂的计算机专业术语，而是轻松地介绍它。</p>
<h2 id="『sequential』_即顺序">『sequential』 即顺序</h2>
<p>这是描述 ES6 生成器中单线程行为和同步风格代码的另一种方式。</p>
<p>还记得一个生成器的语法么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x;</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y * <span class="number">2</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里的每一个表达式是按序执行，<code>yield</code> 关键字虽然指明了生成器中断和恢复的地方，但并没有改变生成器函数中从上到下执行的顺序，对吧？</p>
<h2 id="『Processes』_即进程">『Processes』 即进程</h2>
<p>每一个生成器表现得就像是一个虚拟的进程，它可以自己中断，向其他生成器(进程)传递信号，且能从其他生成器(进程)接收信号后，恢复自己的执行流程。</p>
<p>如果生成器能够访问共享的内存空间的话（也就是能访问除自己内部的本地变量外的自由变量），它就不是那么独立了。</p>
<p>假设我们有一个不访问外部变量的生成器函数，那么它在理论上就可以执行自己的进程。</p>
<p>但我们通常同时有多个生成器(多进程)绑定在一起，需要彼此间协作以完成任务。</p>
<p>那我们为什么要将生成器分离为多个，而不是合在一起呢？因为我们要做到 <em>功能与关注点的分离(separation of capabilities/concerns)</em> 。</p>
<p>假定我们将 XYZ 任务分离为连续的子任务 X, Y, Z 分别实现，就增加了程序的维护性。举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原来是这样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">XYZ</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'y'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'z'</span>);</div><div class="line">}</div><div class="line"><span class="comment">// 可以拆分为：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">X</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'x'</span>);</div><div class="line">    Y();</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Y</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'y'</span>);</div><div class="line">    Z();</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span><span class="params">()</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'z'</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将功能进行模块化划分，增大了程序的可维护性。</p>
<p>同理，对于多生成器(多进程)来说，我们也可以这么做。</p>
<h2 id="『communicating』_即通信">『communicating』 即通信</h2>
<p>生成器(进程)之间互相协作，就需要一个通信频道(communication channel)来传递消息。</p>
<p>实际上，我们并不一定需要在通信频道上传递消息来实现通信，我们可以通过移交控制权的方式来实现。</p>
<p>为什么要通过移交控制权的方式呢？主要是因为 JS 是一个单线程的语言。</p>
<p>单线程意味着同一时刻只能执行一个任务，其他任务排在队列里被挂起(或者说是中断)，等待队列前面的任务完成才能恢复自己的执行。</p>
<p>多个独立的生成器(线程)能够协作和通信好像不是很现实，将多个生成器分离以实现松耦合的目标看似美好但好像不切实际。</p>
<p>可能我是错的，但我并没有找到实现任意两个生成器绑定到一起实现 CSP 匹配的方法。要实现这种设计的话，两个生成器或许需要一个通信协议来支撑。</p>
<h1 id="JS_中的_CSP">JS 中的 CSP</h1>
<p>这里有几个应用于 JS 的 CSP 理论探索。</p>
<p>前面提到的 David Nolen 有几个有趣的项目，包括 <a href="https://github.com/swannodette/om" target="_blank" rel="external">Om</a>、<a href="http://www.hakkalabs.co/articles/core-async-a -clojure-library/" target="_blank" rel="external">core.async</a>。</p>
<p><a href="http://koajs.com/" target="_blank" rel="external">Koa</a> 也有一个有趣的实现，主要是通过它的 <code>use()</code> 方法。</p>
<p>还有一个类似 core.async/Go CSP  API 实现的 <a href="https://github.com/ubolonton/js-csp" target="_blank" rel="external">js-csp</a>。</p>
<p>你可以去了解这几个项目用 JS 实现的不同的 CSP。</p>
<h2 id="asynquence_中_CSP_的实现">asynquence 中 CSP 的实现</h2>
<p>我已经有 asynquence 的 runner() 插件来处理<a href="http://davidwalsh.name/async-generators/#rungenerator-library-utility" target="_blank" rel="external">异步的生成器操作</a>，所以我在这里尝试实现了 CSP 功能。</p>
<p>我需要解决的第一个问题是：我们怎么知道哪一个生成器即将接管控制权呢？</p>
<p>我们可以让每一个生成器都有一些特定的属性如 ID 来告知其他生成器的话，这样做好像比较繁琐笨重。</p>
<p>在经过各种实验后，我选择了一种循环调度的方法：如果我们要将 A, B, C 三个生成器连接起来，且 A 会得到控制权，接着 A 发出 <code>yield</code> 信号将控制权移交给 B, 再接着 B 发出 <code>yield</code> 信号将控制权移交给 C，最后 C 再把控制权移交给 A，形成一个循环。</p>
<p>但我们怎么精确地实现控制呢？有明确的 API 么？同样，在经过很多实验后，我使用了一个巧妙的办法，与 <a href="http://koajs.com/#cascading" target="_blank" rel="external">Koa 中实现的类似</a>：</p>
<p>每一个生成器都有一个指向共享的令牌(token)，对这个令牌  <code>yield</code> 后就会发出一个移交控制的信号。</p>
<p>未完待续。。。<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">http://davidwalsh.name/concurrent-generators</a></p>
]]></content>
    
    
      <category term="ES6" scheme="http://laispace.github.io/tags/ES6/"/>
    
      <category term="generators" scheme="http://laispace.github.io/tags/generators/"/>
    
      <category term="Translate" scheme="http://laispace.github.io/categories/Translate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】ES6 Generators（3）异步篇]]></title>
    <link href="http://laispace.github.io/2014/09/%E3%80%90%E8%AF%91%E3%80%91ES6%20Generators%EF%BC%883%EF%BC%89%E5%BC%82%E6%AD%A5%E7%AF%87/"/>
    <id>http://laispace.github.io/2014/09/【译】ES6 Generators（3）异步篇/</id>
    <published>2014-09-29T10:45:45.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>生成器提供了同步方式编写的代码风格，这就允许我们隐藏异步的实现细节。</p>
<p>我们就可以用一种非常自然的方式来表达程序的执行流程，避免了同时处理异步代码的语法和陷阱。</p>
<p>换句话说，我们利用生成器从内到外、从外到内双向传值的特点，将不同的值的处理交给了不同的生成器逻辑，只需要关心获取到特定的值进行某种操作，而无需关心特定的值如何产生（通过<code>netx()</code> 将值的产生逻辑委托出去）。</p>
<p>这么一来，异步处理的优点以及易读的代码结合到一起，就加强了我们程序的可维护性。</p>
<h1 id="最简单的异步">最简单的异步</h1>
<p>举个栗子，假定我们已经有了以下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span><span class="params">(url,cb)</span> </span>{</div><div class="line">    <span class="comment">// 执行一个 ajax 请求</span></div><div class="line">    <span class="comment">// 请求完成后执行 `cb(result)` </span></div><div class="line">}</div><div class="line"></div><div class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span><span class="params">(result1)</span></span>{</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span><span class="params">(result2)</span></span>{</div><div class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"我们请求到的数据是: "</span> + resp.value );</div><div class="line">    });</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>使用简单的生成器来表达的话，就像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">   <span class="comment">// 调用这个普通函数来隐藏异步处理的细节</span></div><div class="line">   <span class="comment">// 使用 `it.next()` 来恢复调用这个普通函数的生成器函数的迭代器</span></div><div class="line">    makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>{</div><div class="line">        <span class="comment">// 异步获取到数据后，给生成器发送 `response` 信号</span></div><div class="line">        it.next( response );</div><div class="line">    } );</div><div class="line">    <span class="comment">// 注意: 这里没有返回值</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = main();</div><div class="line">it.next(); <span class="comment">// 开始迭代</span></div></pre></td></tr></table></figure>

<p><code>request()</code> 这个工具函数只是将我们的异步请求数据的代码进行了封装，需要注意的是在回调函数中调用了生成器的 <code>next()</code> 方法。</p>
<p>当我们使用 <code>var it = main();</code> 创建了一个迭代器后，紧接着使用 <code>it.next();</code> 开始迭代，这时候遇到第一个 <code>yield</code> 中断了生成器，转而执行 <code>request( &quot;http://some.url.1&quot; )</code></p>
<p>当 <code>request( &quot;http://some.url.1&quot; )</code> 异步获取到数据后，在回调函数中调用 <code>it.next(response)</code> 将 <code>response</code> 传回给生成器刚刚中断的地方，生成器将继续迭代。</p>
<p>这里的亮点就是，我们在生成器中无需关心异步请求的数据如何获取，我们只知道调用了  <code>request()</code> 后，当需要的数据获取到了，就会通知生成器继续迭代。</p>
<p>这么一来在生成器中我们使用同步方式的编写风格，其实我们获取到了异步数据！</p>
<p>同理，当我们继续调用 <code>it.next()</code> 时，会遇到第二个 <code>yield</code> 中断迭代，发出第二个请求 <code>yield request( &quot;http://some.url.2?id=&quot; + data.id )</code> 异步获取到数据后再恢复迭代，我们依旧不用关心异步获取数据的细节了，多爽！</p>
<p>以上这段代码中，<code>request()</code> 请求的是异步 AJAX 请求，但如果我们后续改变程序给 AJAX 设置了缓存了，获取数据会先从缓存中获取，这时候没有执行真正的 AJAX 请求就不能在回调函数中调用 <code>it.next(response)</code> 来恢复生成器的中断了啊！</p>
<p>没关系，我们可以使用一个小技巧来解决这个问题，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 给 AJAX 设置缓存</span></div><div class="line"><span class="keyword">var</span> cache = {};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="comment">// 请求已被缓存</span></div><div class="line">    <span class="keyword">if</span> (cache[url]) {</div><div class="line">        <span class="comment">// 使用 setTimeout 来模拟异步操作</span></div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">            it.next( cache[url] );</div><div class="line">        }, <span class="number">0</span> );</div><div class="line">    }</div><div class="line">    <span class="comment">// 请求未被缓存，发出真正的请求</span></div><div class="line">    <span class="keyword">else</span> {</div><div class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(resp)</span></span>{</div><div class="line">            cache[url] = resp;</div><div class="line">            it.next( resp );</div><div class="line">        } );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看，当我们给我们的程序添加了 AJAX 缓存机制甚至其他异步操作的优化时，我们只改变了  <code>request()</code> 这个工具函数的逻辑，而无需改动调用这个工具函数获取数据的生成器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line">..</div></pre></td></tr></table></figure>

<p>在生成器中，我们还是像以前一样调用 <code>request()</code> 就能获取到需要的异步数据，无需关心获取数据的细节实现！</p>
<p>这就是将异步操作当做一个细节实现抽象出来后展现出的魔力了！</p>
<h1 id="更好的异步">更好的异步</h1>
<p>上面介绍的异步方案对于简单的异步生成器来说工作良好，但用途有限，我们需要一个更强大的异步方案：使用 Promises.</p>
<p>如果你对 ES6 Promises 有迷惑的话，我建议你先读 <a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">我写的介绍 Promises 的文章</a></p>
<p>我们的代码目前有个严重的问题：回调多了会产生多重嵌套（即回调地狱）。</p>
<p>此外，我们目前还缺乏的东西有：</p>
<ol>
<li><p>清晰的错误处理逻辑。我们使用 AJAX 的回调可能会检测到一个错误，然后使用 <code>it.throw()</code> 将错误传回给生成器，在生成器中则使用 <code>try..catch</code> 来捕获错误。<br> 一来我们需要猜测我们可能发生错误且手动添加对应的错误处理函数，二来我们的错误处理代码没法重复使用。</p>
</li>
<li><p>如果 <code>makeAjaxCall()</code> 函数不受我们控制，调用了多次回调的话，也会多次触发回调中的 <code>it.next()</code> ，生成器就会变得非常混乱。</p>
<p> 处理和阻止这种问题需要大量的手动工作，也非常不方便。</p>
</li>
<li><p>有时候我们需要 『并行地』执行不只一个任务（比如同时触发两个 AJAX 请求）。而生成器中的 <code>yield</code> 并不支持两个或多个同时进行。</p>
</li>
</ol>
<p>以上这些问题都可以用手动编写代码的方式来解决，但谁会想每次都重新编写类似的重复的代码呢？</p>
<p>我们需要一个更好的可信任、可重复使用的方案来支持我们基于生成器编写异步的代码。</p>
<p>怎么实现？使用 Promises ！</p>
<p>我们将原来的代码加入 Promises 的特性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="comment">// 注意: 这里返回的是一个 promise</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    } );</div><div class="line">}</div></pre></td></tr></table></figure>

<p><code>request()</code> 函数中创建了一个 promise 实例，一旦 AJAX 请求完成，这个实例将会被 <code>resolved</code>。</p>
<p>我们接着将这个实例返回，这样它就能够被 <code>yield</code> 了。</p>
<p>接下来我们需要一个工具来控制我们生成器的迭代器，接收返回的 promise 实例，然后再通过 <code>next()</code> 来恢复生成器的中断：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 执行异步的生成器</span></div><div class="line"><span class="comment">// 注意: 这是简化的版本，没有处理错误</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span><span class="params">(g)</span> </span>{</div><div class="line">    <span class="comment">// 注意：我们使用 `g()` 自动初始化了迭代器</span></div><div class="line">    <span class="keyword">var</span> it = g(), ret;</div><div class="line"></div><div class="line">    <span class="comment">// 异步地迭代</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">(val)</span></span>{</div><div class="line">        ret = it.next( val );</div><div class="line"></div><div class="line">        <span class="comment">// 迭代未完成</span></div><div class="line">        <span class="keyword">if</span> (!ret.done) {</div><div class="line">            <span class="comment">// 判断是否为 promise 对象，如果没有 `then()` 方法则不是</span></div><div class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) {</div><div class="line">                <span class="comment">// 等待 promise 返回</span></div><div class="line">                ret.value.then( iterate );</div><div class="line">            }</div><div class="line">            <span class="comment">// 如果不是 promise 实例，则说明直接返回了一个值</span></div><div class="line">            <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// 使用 `setTimeout` 模拟异步操作</span></div><div class="line">                setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">                    iterate( ret.value );</div><div class="line">                }, <span class="number">0</span> );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    })();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意：我们在 <code>runGenerator()</code> 中先生成了一个迭代器 <code>var it = g()</code>，然后我们会执行这个迭代器直到它完成(<code>done: true</code>)。</p>
<p>接着我们就可以使用这个 <code>runGenerator()</code> 了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"你请求的数据是: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>我们通过生成不同的 promise 实例，分别对这些实例进行 <code>yield</code>，不同的实例等待自己的 promise 被 <code>resolve</code> 后再执行对应的操作。</p>
<p>这么一来，我们只需要同时生成不同的 promise 实例，就可以『并行地』执行不只一个任务（比如同时触发两个 AJAX 请求）了。</p>
<p>既然我们使用了 promises 来管理生成器中处理异步的代码，我们就解决了只有在回调中才能实现的功能，这就避免了回调嵌套了。</p>
<p>使用 Generotos + Promises 的优点是：</p>
<ol>
<li><p>我们可以使用内建的错误处理机制。虽然这没有在上面的代码片段中展示出来，但其实很简单：</p>
<p> 监听 promise 中的错误，使用 <code>it.throw()</code> 把错误抛出，然后在生成器中使用 <code>try..catch</code> 进行捕获和处理即可。</p>
</li>
<li><p>我们可以使用到 Promises 提供的 <a href="http://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">control/trustability</a> 特性。</p>
</li>
<li><p>Promises 提供了大量处理多并行且复杂的任务的特性。</p>
<p> 举个栗子：<code>yield Promise.all([ .. ])</code> 方法接收一组 promise 组成的数组作为参数，然后 <code>yield</code> 一个 promise 提供给生成器处理，这个 promise 会等待数组里所有 promise 完成。当我们得到 <code>yield</code> 后的 promise 时，说明传进去的数组中的所有 promise 都已经完成，且是按照他们被传入的顺序完成的。</p>
</li>
</ol>
<p>首先，我们体验一下错误处理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 假设1: `makeAjaxCall(..)` 第一个参数判断是否有错误产生</span></div><div class="line"><span class="comment">// 假设2: `runGenerator(..)` 能捕获并处理错误</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span><span class="params">(err,text)</span></span>{</div><div class="line">            <span class="comment">// 如果出错，则 reject 这个 promise</span></div><div class="line">            <span class="keyword">if</span> (err) reject( err );</div><div class="line">            <span class="comment">// 否则，resolve 这个 promise</span></div><div class="line">            <span class="keyword">else</span> resolve( text );</div><div class="line">        } );</div><div class="line">    } );</div><div class="line">}</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="comment">// 捕获第一个请求的错误</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line">    </div><div class="line">    <span class="comment">// 捕获第二个请求的错误</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    } <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"你请求的数据是: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p>如果一个 promise 被 <code>reject</code> 或遇到其他错误的话，将使用 <code>it.throw()</code> (代码片段中没有展示出来)抛出一个生成器的错误，这个错误能被 <code>try..catch</code> 捕获。</p>
<p>再举个使用 Promises 管理更复杂的异步操作的栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise( <span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span></span>{</div><div class="line">        makeAjaxCall( url, resolve );</div><div class="line">    } )</div><div class="line">    <span class="comment">// 对 promise 返回的字符串进行后处理操作</span></div><div class="line">    .then( <span class="function"><span class="keyword">function</span><span class="params">(text)</span></span>{</div><div class="line">        <span class="comment">// 是否为一个重定向链接</span></div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) {</div><div class="line">            <span class="comment">// 是的话对向新链接发送请求</span></div><div class="line">            <span class="keyword">return</span> request( text );</div><div class="line">        }</div><div class="line">        <span class="comment">// 否则，返回字符串</span></div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">return</span> text;</div><div class="line">        }</div><div class="line">    } );</div><div class="line">}</div><div class="line"></div><div class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> search_terms = <span class="keyword">yield</span> Promise.all( [</div><div class="line">        request( <span class="string">"http://some.url.1"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.2"</span> ),</div><div class="line">        request( <span class="string">"http://some.url.3"</span> )</div><div class="line">    ] );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> search_results = <span class="keyword">yield</span> request(</div><div class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</div><div class="line">    );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( search_results );</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results: "</span> + resp.value );</div><div class="line">} );</div></pre></td></tr></table></figure>

<p><code>Promise.all([ .. ])</code> 构造了一个 promise ，等待数组中三个 promise 的完成，这个 promise 会被 <code>yield</code> 给 <code>runGenerator()</code> 生成器，然后这个生成器就可以恢复迭代。</p>
<h1 id="使用其他的_Promise_类库">使用其他的 Promise 类库</h1>
<p>在上面的代码片段中，我们自己编写了 <code>runGenerator()</code> 函数来提供 Generators + Promises 的功能，其实我们也可以使用社区里优秀的类库，举几个栗子： <a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a> 、<a href="https://github.com/visionmedia/co" target="_blank" rel="external">Co</a>、 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">asynquence</a> 等</p>
<p>接下来我会简要地介绍下 <a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a> 中的 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">runner插件</a> 。如果你感兴趣的话，可以阅读我写的<a href="http://davidwalsh.name/asynquence-part-1/" target="_blank" rel="external">两篇深入理解 asynquence 的博文</a>。</p>
<p>首先，asynquence 提供了回调函数中错误为第一参数的编写风格(error-first style)，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>{</div><div class="line">    <span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line">        <span class="comment">// 传进一个以错误为第一参数的回调函数</span></div><div class="line">        makeAjaxCall( url, done.errfcb );</div><div class="line">    } );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着，asynquence 的 runner 插件会接收一个生成器作为参数，这个生成器可以处理传入的数据处理后再传出来，而所有的的错误会自动地传递：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我们使用 `getSomeValues()` 来产生一组 promise，并链式地进行异步操作</span></div><div class="line">getSomeValues()</div><div class="line"></div><div class="line"><span class="comment">// 现在使用一个生成器来处理接收到的数据</span></div><div class="line">.runner( <span class="function"><span class="keyword">function</span>*<span class="params">(token)</span></span>{</div><div class="line">    <span class="keyword">var</span> value1 = token.messages[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> value2 = token.messages[<span class="number">1</span>];</div><div class="line">    <span class="keyword">var</span> value3 = token.messages[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 并行地执行三个 AJAX 请求</span></div><div class="line">    <span class="comment">// 注意: `ASQ().all(..)` 就像之前提过的 `Promise.all(..)`</span></div><div class="line">    <span class="keyword">var</span> msgs = <span class="keyword">yield</span> ASQ().all(</div><div class="line">        request( <span class="string">"http://some.url.1?v="</span> + value1 ),</div><div class="line">        request( <span class="string">"http://some.url.2?v="</span> + value2 ),</div><div class="line">        request( <span class="string">"http://some.url.3?v="</span> + value3 )</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// 当三个请求都执行完毕后，进入下一步</span></div><div class="line">    <span class="keyword">yield</span> (msgs[<span class="number">0</span>] + msgs[<span class="number">1</span>] + msgs[<span class="number">2</span>]);</div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 现在使用前面的生成器返回的值作为参数继续发送 AJAX 请求</span></div><div class="line">.seq( <span class="function"><span class="keyword">function</span><span class="params">(msg)</span></span>{</div><div class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.4?msg="</span> + msg );</div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 完成了一系列请求后，我们就获取到了想要的数据</span></div><div class="line">.val( <span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>{</div><div class="line">    <span class="built_in">console</span>.log( result ); <span class="comment">// 获取数据成功!</span></div><div class="line">} )</div><div class="line"></div><div class="line"><span class="comment">// 如果产生错误，则抛出</span></div><div class="line">.or( <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">} );</div></pre></td></tr></table></figure>

<h1 id="ES7_async">ES7 async</h1>
<p>在 ES7 草案中有一个提议，建议采用另一种新的 <code>async</code> 函数类型。</p>
<p>使用这种函数，我们可以向外部发出 promises，然后使用 <code>async</code> 函数自动地将这些 promises 连接起来，当 promises 完成的时候，就会恢复 <code>async</code> 函数自己的中断（不需要在繁杂的迭代器中手动恢复）。</p>
<p>这个提议如果被采纳的话，可能会像这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> result1 = await request( <span class="string">"http://some.url.1"</span> );</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result2 = await request( <span class="string">"http://some.url.2?id="</span> + data.id );</div><div class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</div><div class="line">}</div><div class="line"></div><div class="line">main();</div></pre></td></tr></table></figure>

<p>我们使用 <code>async</code> 声明了这种异步函数类型，然后使用 <code>main()</code> 直接调用这个函数，而不用像使用 <code>runGenerator()</code> 或 <code>ASQ().runner()</code> 一样进行包装。</p>
<p>此外，我们没有使用 <code>yield</code> 关键字，而是使用了新的 <code>await</code> 关键字来声明等待 <code>await</code> 后面的 promise 的完成。</p>
<h1 id="总结">总结</h1>
<p>一言以蔽之：Generators + Promises 的组合，强大且优雅地用同步编码风格实现了复杂的异步控制操作。</p>
<p>使用一些简单的工具类库，比如上面提到的 <a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a> 、<a href="https://github.com/visionmedia/co" target="_blank" rel="external">Co</a>、 <a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external">asynquence</a> 等，我们可以更方便地实现这些操作。</p>
<p>可以预见在不久的将来，当 ES7+ 发布的时候，我们使用 <code>async</code> 函数甚至可以无需使用一些类库支撑就可以实现原生的异步生成器了！</p>
<p>(译注：本文是第三篇文章，其实还有最后一篇是讲述并发式生成器的实现思路，涉及到 CSP 的相关概念，原文中引用了比较多的东西，读起来比较晦涩难懂，怕翻译出来与原文作者想要表达的东西相差太远，就先放一边了，感兴趣的可以直接<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">查看原文</a>。<br>欢迎大牛接力)</p>
]]></content>
    
    
      <category term="ES6" scheme="http://laispace.github.io/tags/ES6/"/>
    
      <category term="generators" scheme="http://laispace.github.io/tags/generators/"/>
    
      <category term="Translate" scheme="http://laispace.github.io/categories/Translate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】ES6 Generators（2）深入篇]]></title>
    <link href="http://laispace.github.io/2014/09/%E3%80%90%E8%AF%91%E3%80%91ES6%20Generators%EF%BC%882%EF%BC%89%E6%B7%B1%E5%85%A5%E7%AF%87/"/>
    <id>http://laispace.github.io/2014/09/【译】ES6 Generators（2）深入篇/</id>
    <published>2014-09-28T10:45:45.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p>如果你仍然对 ES6 Generators 不熟悉的话，建议你先阅读并运行 <a href="">【译】ES6 Generators 基础篇（1）</a> 中的代码片段，理解了生成器的基础知识后，就可以阅读这篇文章了解更多的细节啦。</p>
<h1 id="错误处理">错误处理</h1>
<p>ES6 中生成器的其中一个强大的特点就是：函数内部的代码编写风格是同步的，即使外部的迭代控制过程可能是异步的。</p>
<p>也就是说，我们可以简单地对错误进行处理，类似我们熟悉的 <code>try..catch</code> 语法，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x ); <span class="comment">// 如果出错，这里可能永远不会执行</span></div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>即使这个生成器可能会在 <code>yield 3</code> 处中断，当接收到外部传入的错误时，<code>try..catch</code> 将会捕获到。</p>
<p>具体一个错误是怎样传入生成器的呢，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line"><span class="keyword">var</span> res = it.next(); <span class="comment">// { value:3, done:false }</span></div><div class="line"></div><div class="line"><span class="comment">// 我们在这里不调用 it.next() 传值进去，而是触发一个错误</span></div><div class="line">it.<span class="keyword">throw</span>( <span class="string">"Oops!"</span> ); <span class="comment">// Error: Oops!</span></div></pre></td></tr></table></figure>

<p>我们可以使用 <code>throw()</code> 方法产生错误传进生成器中，那么在生成器中断的地方，即 <code>yield 3</code> 处会产生错误，然后被 <code>try..catch</code> 捕获。</p>
<p>注意：如果我们使用 <code>throw()</code> 方法产生一个错误传进生成器中，但没有对应的 <code>try..catch</code> 对错误进行捕获的话，这个错误将会被传出去，外部如果不对错误进行捕获的话，则会抛出异常：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{ }</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"><span class="comment">// 在外部进行捕获</span></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    it.throw( <span class="string">"Oops!"</span> );</div><div class="line">}</div><div class="line"><span class="keyword">catch</span> (err) {</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err ); <span class="comment">// Error: Oops!</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>当然，我们也可以进行反方向的错误捕获：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> y = x.toUpperCase(); <span class="comment">// 若 x 不是字符串的话，将抛出TypeError 错误</span></div><div class="line">    <span class="keyword">yield</span> y;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:3, done:false }</span></div><div class="line"></div><div class="line"><span class="keyword">try</span> {</div><div class="line">    it.next( <span class="number">42</span> ); <span class="comment">// `42` 是数字没有 `toUpperCase()` 方法，所以会出错</span></div><div class="line">}</div><div class="line"><span class="keyword">catch</span> (err) {</div><div class="line">    <span class="built_in">console</span>.log( err ); <span class="comment">// 捕获到 TypeError 错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="生成器委托">生成器委托</h1>
<p>另一个我们想做的可能是在一个生成器中调用另一个生成器。</p>
<p>我并不是指在一个生成器中初始化另一个生成器，而是说我们可以将一个生成器的迭代器控制交给另一个生成器。</p>
<p>为了实现委托，我们需要用到 <code>yield</code> 关键字的另一种形式：<code>yield *</code>，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` 将迭代器控制委托给了 `foo()`</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v of bar()) {</div><div class="line">    <span class="built_in">console</span>.log( v );</div><div class="line">}</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div></pre></td></tr></table></figure>

<p>以上这段代码应该通俗易懂：当生成器 <code>bar()</code> 迭代到 <code>yield 2</code> 时，先将控制权交给了另一个生成器 <code>foo()</code>迭代完后再将控制权收回，继续进行迭代。</p>
<p>这里使用了 <code>for..of</code> 循环进行示例，正如在基础篇我们知道 <code>for..of</code> 循环中没有暴露出 <code>next()</code> 方法来传递值到生成器中，所以我们可以用手动的方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> w = <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"z: "</span> + z + <span class="string">", w: "</span> + w );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` 将迭代器控制委托给了 `foo()`</span></div><div class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x + <span class="string">", y: "</span> + y + <span class="string">", v: "</span> + v );</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = bar();</div><div class="line"></div><div class="line">it.next();      <span class="comment">// { value:1, done:false }</span></div><div class="line">it.next( <span class="string">"X"</span> ); <span class="comment">// { value:2, done:false }</span></div><div class="line">it.next( <span class="string">"Y"</span> ); <span class="comment">// { value:3, done:false }</span></div><div class="line">it.next( <span class="string">"Z"</span> ); <span class="comment">// { value:4, done:false }</span></div><div class="line">it.next( <span class="string">"W"</span> ); <span class="comment">// { value:5, done:false }</span></div><div class="line"><span class="comment">// z: Z, w: W</span></div><div class="line"></div><div class="line">it.next( <span class="string">"V"</span> ); <span class="comment">// { value:undefined, done:true }</span></div><div class="line"><span class="comment">// x: X, y: Y, v: V</span></div></pre></td></tr></table></figure>

<p>尽管我们在这里只展示了一层的委托关系，但具体场景中我们当然可以使用多层的嵌套。</p>
<p>一个 <code>yield *</code> 技巧是，我们可以从被委托的生成器（比如示例中的 <code>foo()</code>） 获取到返回值，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function *foo() {</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>; <span class="regexp">//</span> 返回一个值给 `<span class="keyword">yield</span>*` 表达式</div><div class="line">}</div><div class="line"></div><div class="line">function *bar() {</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    var v = <span class="keyword">yield</span> *foo();</div><div class="line">    console.log( <span class="string">"v: "</span> + v );</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">}</div><div class="line"></div><div class="line">var it = bar();</div><div class="line"></div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">1</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">2</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">3</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> <span class="string">"v: foo"</span>   { <span class="symbol">value:</span><span class="number">4</span>, <span class="symbol">done:</span><span class="keyword">false</span> } 注意：在这里获取到了返回的值</div><div class="line">it.<span class="keyword">next</span>(); <span class="regexp">//</span> { <span class="symbol">value:</span>undefined, <span class="symbol">done:</span><span class="keyword">true</span> }</div></pre></td></tr></table></figure>

<p><code>yield *foo()</code> 得到了 <code>bar()</code> 的控制权，完成了自己的迭代操作后，返回了一个 <code>v: foo</code> 值 给<code>bar()</code> ，然后 <code>bar()</code> 再继续迭代下去。</p>
<p><code>yield</code> 和 <code>yield *</code> 表达式的一个有趣的区别是：在 <code>yield</code> 中，返回值在 <code>next()</code> 中传入的，而在 <code>yield *</code> 中，返回值是在 <code>return</code> 中传入的。</p>
<p>此外，我们也可以在委托的生成器中进行双向的错误绑定，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"foo caught: "</span> + err );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">yield</span>; <span class="comment">// 中断</span></div><div class="line"></div><div class="line">    <span class="comment">// 现在抛出另一个错误</span></div><div class="line">    <span class="keyword">throw</span> <span class="string">"Oops!"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">yield</span> *foo();</div><div class="line">    }</div><div class="line">    <span class="keyword">catch</span> (err) {</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">"bar caught: "</span> + err );</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = bar();</div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:1, done:false }</span></div><div class="line">it.next(); <span class="comment">// { value:2, done:false }</span></div><div class="line"></div><div class="line">it.throw( <span class="string">"Uh oh!"</span> ); <span class="comment">// 将会在 `foo()` 内部捕获</span></div><div class="line"><span class="comment">// foo caught: Uh oh!</span></div><div class="line"></div><div class="line">it.next(); <span class="comment">// { value:undefined, done:true }  --&gt; 这里没有错误</span></div><div class="line"><span class="comment">// bar caught: Oops!</span></div></pre></td></tr></table></figure>

<p><code>throw( &quot;Uh oh!&quot; )</code> 在代理给 <code>foo()</code> 的过程中，抛了个错误进去，所以错误在 <code>foo()</code> 中被捕获。</p>
<p>同理，<code>throw &quot;Oops!&quot;</code>  在 <code>foo()</code> 内部抛出的错误，将会传回给 <code>bar()</code> 后，被 <code>bar()</code> 中的 <code>try..catch</code> 捕获到。</p>
<h1 id="总结">总结</h1>
<p>生成器有着同步方式的编写语法，意味着我么可以使用 <code>try..catch</code> 在 <code>yield</code> 表达式中进行错误处理。</p>
<p>生成器迭代器中也有一个 <code>throw()</code> 方法用于在中断期间向生成器内部传入一个错误，这个错误能被生成器内部的 <code>try..catch</code> 捕获。</p>
<p><code>yield *</code> 允许我们将迭代器的控制权从当前的生成器中委托给另一个生成器。好处是 <code>yield *</code> 扮演了在生成器间传递消息和错误的角色。</p>
<p>了解了这么多，还有一个很重要的问题没有解决：</p>
<p>怎么异步地使用生成器呢？</p>
<p>关键是要实现这么一个机制：在异步环境中，当迭代器的 <code>next()</code> 方法被调用，我们需要定位到生成器中断的地方重新启动。</p>
<p>别担心，请听下回分解：）</p>
]]></content>
    
    
      <category term="ES6" scheme="http://laispace.github.io/tags/ES6/"/>
    
      <category term="generators" scheme="http://laispace.github.io/tags/generators/"/>
    
      <category term="Translate" scheme="http://laispace.github.io/categories/Translate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】ES6 Generators（1）基础篇]]></title>
    <link href="http://laispace.github.io/2014/09/%E3%80%90%E8%AF%91%E3%80%91ES6%20Generators%EF%BC%881%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://laispace.github.io/2014/09/【译】ES6 Generators（1）基础篇/</id>
    <published>2014-09-27T10:45:45.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>译注1：此文带着自己的理解，不完全按原文翻译。<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">原文地址</a></p>
<p>译注2：原文晦涩难懂的地方，尽力做了注释或修饰，方便大家理解。错误之处欢迎各位校验指正。</p>
</blockquote>
<p><em>generator</em> 即生成器，是 ES6 中众多特性中的一种，是一个新的函数类型。</p>
<p>这篇文章旨在介绍 generator 的基础知识，以及告诉你在 JS 的未来，他们为何如此重要。</p>
<h1 id="运行直到完成_(Run-To-Completion)">运行直到完成 (Run-To-Completion)</h1>
<p>为了理清这个新的函数类型和其他函数类型有何区别，我们首先需要了解 『run to completion』 的概念。</p>
<p>我们知道 JS 是单线程的，所以一旦一个函数开始执行，排在队列后边的函数就必须等待这个函数执行完毕。</p>
<p>举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</div><div class="line">},<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="comment">// 注意: 永远不要使用这种超长的循环，这里只是为了演示方便</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">1E10</span>; i++) {</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">foo();</div><div class="line"><span class="comment">// 0..1E10</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure>

<p>在这段代码中，我们先执行了 <code>foo()</code> 然后执行 <code>setTimeout</code>，而 <code>foo()</code> 中的 for 循环将花费超长的时间才能完成。</p>
<p>只有等待这个漫长的循环结束后，<code>setTimeout</code> 中的 <code>console.log(&#39;Hello World&#39;)</code> 才能执行。</p>
<p>如果 <code>foo()</code> 函数能够被中断会怎样呢？</p>
<p>这是多线程编程语言的挑战，但我们并不需要考虑这个，因为 JS 是单线程的。</p>
<h1 id="运行可被中止_(Run-Stop-Run)">运行可被中止 (Run..Stop..Run)</h1>
<p>使用 ES6 的生成器特性，我们有了一种新的函数类型：</p>
<p>允许这个函数的执行被中断一次或多次，在中断的期间我们可以去做其他操作，完成后再回来恢复这个函数的执行。</p>
<p>如果你了解过其他并发型或多线程的语言的话，你可能知道『协作(cooperative)』：</p>
<p>在一个函数执行期间，允许执行中断，在中断期间与其他代码进行协作。</p>
<p>ES6 生成器函数在并发行为中体现了这种『协作』的特性。</p>
<p>在生成器函数体中，我们可以使用一个新的 <code>yield</code> 关键字在内部来中断函数的执行。</p>
<p>需要注意的是，生成器并不能恢复自己中断的执行，我们需要一个额外的控制来恢复函数的执行。</p>
<p>所以，一个生成器函数能够被中断和重启。那生成器函数中断自己的执行后，怎么才知道何时恢复执行呢？</p>
<p>我们可以使用 <code>yield</code> 来对外发送中断的信号，当外部返回信号时再恢复函数的执行。</p>
<h1 id="生成器的语法">生成器的语法</h1>
<p>我们可以这样声明一个生成器函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> *foo() {</div><div class="line">    // <span class="keyword">...</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意这里的星号(*)即声明了这个函数是属于生成器类型的函数。</p>
<p>生成器函数大多数功能与普通函数没有区别，只有一部分新颖的语法需要学习。</p>
<p>先介绍一个 <code>yield</code> 关键字：</p>
<p><code>yield ___</code> 也叫做 『yield 表达式』，当我们重启生成器时，会向函数内部传值，这个值为对应的 <code>yield ___</code> 表达式的计算结果。</p>
<p>举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</div><div class="line">    <span class="built_in">console</span>.log(x);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这段代码中， <code>yield &quot;foo&quot;</code> 表达式将在函数中断时，向外部发送 “foo” 这个值，且当这个生成器重启时，外部传入的值将作为这个表达式的结果：</p>
<p>在这里，外部传入的值将会与 <code>1</code> 进行相加操作，然后赋值给 <code>x</code>。</p>
<p>看到双向通信的特点了么？我们在生成器内部向外发送 “foo” 然后中断函数执行，然后当生成器接收到外部传入一个值时，生成器将重启，函数将恢复执行。</p>
<p>如果我们只是向中止函数而不对外传值时，只使用 <code>yield</code> 即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意: `foo(..)` 在这里并不是一个生成器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span>; <span class="comment">// 只是中断，而不向外传值</span></div><div class="line">    foo( <span class="keyword">yield</span> ); <span class="comment">// 当外部传回一个值时，将执行 foo() 操作</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="生成器迭代器(Generator_Iterator)">生成器迭代器(Generator Iterator)</h1>
<p>迭代器是一种设计模式，定义了一种特殊的行为：</p>
<p>我们通过 <code>next()</code> 来获取一组有序的值。</p>
<p>举个栗子：我们有个数组为 [1, 2, 3, 4, 5]，第一次调用 <code>next()</code> 将返回 1，第二次调用 <code>next()</code> 将返回 2，以此类推，当数组内的值都返回完毕时，继续调用 <code>next()</code>将返回 null 或 false。</p>
<p>为了从外部控制生成器函数，我们使用生成器迭代器(generator iterator)来实现，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们先定义了一个生成器函数 <code>foo()</code>，接着我们调用它一次来生成一个迭代器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var it </span>=<span class="string"> foo();</span></div></pre></td></tr></table></figure>

<p>你可能会疑问为啥我们不是使用 <code>new</code> 关键字即 <code>var it = new foo()</code> 来生成迭代器？好吧，这语法背后比较复杂已经超出了我们的讨论范围了。</p>
<p>接下来我们就可以使用这个迭代器了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="keyword">false</span> }</div></pre></td></tr></table></figure>

<p>这里的 <code>it.next()</code> 返回 <code>{ value: 1, done: false }</code>，其中的 <code>value: 1</code> 是 <code>yield 1</code> 返回的值，而 <code>done: false</code> 表示生成器函数还没有迭代完成。</p>
<p>继续调用 <code>it.next()</code> 进行迭代：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">2</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">3</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">4</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span><span class="number">5</span>, <span class="symbol">done:</span><span class="keyword">false</span> }</div></pre></td></tr></table></figure>

<p>注意我们迭代到值为 <code>5</code>时，<code>done</code> 还是为 <code>false</code>，是因为这时候生成器函数并未处于完成状态，我们再调用一次看看：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log( it.<span class="keyword">next</span>() ); <span class="regexp">//</span> { <span class="symbol">value:</span>undefined, <span class="symbol">done:</span><span class="keyword">true</span> }</div></pre></td></tr></table></figure>

<p>这时候我们已经执行完了所有的 <code>yield ___</code> 表达式，所以 <code>done</code> 已经为 <code>true</code>。</p>
<p>你可能会好奇的是：如果我们在一个生成器函数中使用了 <code>return</code>，我们在外部还能获取到 <code>yield</code> 的值么？</p>
<p><em>答案可以是：能</em></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// { value:1, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// { value:2, done:true }</span></div></pre></td></tr></table></figure>

<p>让我们看看当我们使用迭代器时，生成器怎么对外传值，以及怎么接收外部传入的值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">(x)</span> </span>{</div><div class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</div><div class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</div><div class="line">    <span class="keyword">return</span> (x + y + z);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo( <span class="number">5</span> );</div><div class="line"></div><div class="line"><span class="comment">// 注意：这里没有给 `it.next()` 传值</span></div><div class="line"><span class="built_in">console</span>.log( it.next() );       <span class="comment">// { value:6, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next( <span class="number">12</span> ) );   <span class="comment">// { value:8, done:false }</span></div><div class="line"><span class="built_in">console</span>.log( it.next( <span class="number">13</span> ) );   <span class="comment">// { value:42, done:true }</span></div></pre></td></tr></table></figure>

<p>我们传入参数 <code>5</code> 先初始化了一个迭代器。</p>
<p>第一个 <code>next()</code> 中没有传递参数进去，因为这个生成器函数中没有对应的 <code>yield</code> 来接收参数，所以如果我们在第一个 <code>next()</code> 强制传参进去的话，什么都不会发生。<br>第一个 <code>yield (x+1)</code> 将返回 <code>value: 6</code> 到外部，此时生成器未迭代完毕，所以同时返回 <code>done: false</code> 。</p>
<p>第二个 <code>next(12)</code> 中我们传递了参数 <code>12</code> 进去，则表达式 <code>yield(x+1)</code> 会被赋值为 12，相当于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span> * <span class="number">12</span>; <span class="comment">// =&gt; 24</span></div></pre></td></tr></table></figure>

<p>第二个 <code>yield (y/3)</code> 将返回 <code>value: 8</code> 到外部，此时生成器未迭代完毕，所以同时返回 <code>done: false</code> 。</p>
<p>同理，在第三个 <code>next(13)</code> 中我们传递了参数 <code>13</code> 进去，则表达式 <code>yield(y/3)</code> 会被赋值为 13，相当于：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> y = <span class="number">24</span>;</div><div class="line"><span class="keyword">var</span> z = <span class="number">13</span>;</div></pre></td></tr></table></figure>

<p>第三个 <code>yield</code>并不存在，所以会 <code>return (x + y + z)</code> 即返回 <code>value: 42</code> 到外部，此时生成器已迭代完毕，所以同时返回 <code>done: true</code> 。</p>
<p><em>答案也可以是：不能！</em></p>
<p>依赖  <code>return</code> 从生成器中返回一个值并不好，因为当生成器遇见了 <code>for..of</code> 循环的时候，被返回的值将会被丢弃，举个栗子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v of foo()) {</div><div class="line">    <span class="built_in">console</span>.log( v );</div><div class="line">}</div><div class="line"><span class="comment">// 1 2 3 4 5</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( v ); <span class="comment">// 仍然是 `5`, 而不是 `6`</span></div></pre></td></tr></table></figure>

<p>看到了吧？由 <code>foo()</code> 创建的迭代器会被 <code>foo..of</code> 循环自动捕获，且会自动进行一个接一个的迭代，直到遇到 <code>done: true</code>，就结束了，并没有处理 <code>return</code> 的值。</p>
<p>所以，<code>for..of</code> 循环会忽略被返回的 <code>6</code>，同时因为没有暴露出 <code>next()</code> 方法，<code>for..of</code> 循环就不能用于我们在中断生成器的期间，对生成器进行传值的场景。</p>
<h1 id="总结">总结</h1>
<p>看了以上 ES6 Generators 的基础知识，很自然地就会想我们在什么场景下会用到这个新颖的生成器呢？</p>
<p>当然有很多的场景能发挥生成器的这些特性了，这篇文章只是抛砖引玉，我们将继续深入挖掘生成器的魔力！</p>
<p>当你在最新的 Chrome nightly 或 canary 版，或 Firefox nightly版，甚至在 v0.11+ 版本的 node （带 —harmony 开启 ES6 功能）中运行了以上这些代码片段后，我们可能会产生以下疑问：</p>
<ol>
<li>怎么进行错误处理呢？</li>
<li>一个生成器怎么调用另一个生成器呢？</li>
<li>怎么异步地使用生成器呢？</li>
</ol>
<p>别担心，请听下回分解：）</p>
]]></content>
    
    
      <category term="ES6" scheme="http://laispace.github.io/tags/ES6/"/>
    
      <category term="generators" scheme="http://laispace.github.io/tags/generators/"/>
    
      <category term="Translate" scheme="http://laispace.github.io/categories/Translate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[慎用text-indent的负值]]></title>
    <link href="http://laispace.github.io/2014/09/%E6%85%8E%E7%94%A8text-indent%E7%9A%84%E8%B4%9F%E5%80%BC/"/>
    <id>http://laispace.github.io/2014/09/慎用text-indent的负值/</id>
    <published>2014-09-25T07:15:02.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>为了语义化，我们可能会利用图片替换文字的方式来给我们的站点增色，举个栗子：</p>
<pre><code>        &lt;p&gt;文字文字&lt;/p&gt;

        p {
            text-indent: -<span class="number">2500</span>px;        <span class="comment">// 小，在高分辨率宽屏下文字隐藏失败</span>
            <span class="comment">//text-indent: -99999px;     // 大，但可能存在性能问题，甚至被搜索引擎屏蔽</span>
            background: url(logo.png);
        }
</code></pre><p>  这段代码中我们希望隐藏文字，提升 SEO，所以使用 logo.png 这个图片进行替换，这时会对文字设置一个负缩进值。</p>
<p>  这里的 -2500px 在以前基本可以解决隐藏文字的问题，但目前发现高分辨率浏览器下这个值已经在浏览器可视范围内了，造成文字隐藏失败的问题。</p>
<p>  而如果将这个值设置为更大，如 -99999px 时，又会造成浏览器的性能问题：浏览器需要生成一个宽度为 99999px 的盒模型，所以也要限制这个值的大小。</p>
<p>  还有人指出，不少人滥用这个属性为了提升 SEO ，而搜索引擎可能会反过来屏蔽这里的文字。</p>
<p>  除此之外，在从右到左读的语言环境中，这个负值可能会造成很长的横向滚动条，所以可以添加 direction 规则来避免：</p>
<pre><code>         <span class="tag">p</span> {
            <span class="attribute">text-indent</span><span class="value">: -<span class="number">9999px</span>;</span> <span class="comment">// 万一日后用户屏幕宽度达到1万肿么办？（这好像不可能。。。）</span>
            <span class="attribute">background</span><span class="value">: <span class="function">url</span>(logo.png);</span>
            <span class="attribute">direction</span><span class="value">: ltr;</span> <span class="comment">// 设置为从左到右读的方向，避免 rtl 语言环境下出现横向滚动条</span>
        }
</code></pre><p> 一个比较好的可选方案：</p>
<pre><code>        <span class="tag">p</span> <span class="rules">{ 
            <span class="rule"><span class="attribute">text-indent</span>:<span class="value"> <span class="number">100%</span></span></span>; 
            <span class="rule"><span class="attribute">white-space</span>:<span class="value"> nowrap</span></span>; 
            <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>; 
            <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(logo.png)</span></span>;
        <span class="rule">}</span></span>
</code></pre><p> 参考链接：</p>
<ul>
<li><a href="https://github.com/CSSLint/csslint/wiki/disallow-negative-text-indent" target="_blank" rel="external">Disallow negative text indent</a></li>
<li><a href="http://luigimontanez.com/2010/stop-using-text-indent-css-trick/" target="_blank" rel="external">Stop Using the text-indent:-9999px CSS Trick</a></li>
<li><a href="http://css-tricks.com/examples/ImageReplacement/" target="_blank" rel="external">CSS Image Replacement</a></li>
</ul>
]]></content>
    
    
      <category term="CSS" scheme="http://laispace.github.io/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 workspace 和 source map 功能在 chrome 中修改并保存文件]]></title>
    <link href="http://laispace.github.io/2014/09/%E4%BD%BF%E7%94%A8-workspace-%E5%92%8C-source-map-%E5%8A%9F%E8%83%BD%E5%9C%A8-chrome-%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%B9%B6%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/"/>
    <id>http://laispace.github.io/2014/09/使用-workspace-和-source-map-功能在-chrome-中修改并保存文件/</id>
    <published>2014-09-01T07:33:32.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>创建测试文件</p>
<p>创建 test/test.html，引入 test/test.css </p>
</li>
<li><p>打开本地服务器</p>
<p> 这时候审查 test.html 的页面元素修改其 css 属性并不会生效。</p>
</li>
<li><p>建立本地和服务器的文件映射</p>
<ol>
<li>打开 chrome dev tools</li>
<li>设置 Workspace，添加文件夹 test/</li>
<li><p>双击这个新增的文件夹，增加映射</p>
<p> URL prefix 填写浏览器地址栏对应的服务器根目录</p>
<p> Folder path 填写本地文件夹的路径</p>
</li>
</ol>
</li>
<li><p>审查元素，修改 test.html 中的元素的 css 属性</p>
<p> 用编辑器打开 test.css 就会发现修改保存到了文件中了。</p>
</li>
</ol>
<ol>
<li><p>使用 Sass 更进一步</p>
<p> 上述方法能直接将我们在浏览器中对 css 的修改保存到本地文件中，</p>
<p> 但我们可能不是直接编写 css 文件，而是使用了 Sass/Less 等预编译工具，这时候 source map 功能就派上用场了。</p>
</li>
<li><p>配置 source map 让 chrome 支持 Sass </p>
<p> 小赖使用的是 Webstorm 的 Sass 插件，其能监听 scss 文件的改变，自动生成新的 css 文件。</p>
<p> 但默认一个 scss 文件只会生成对应的 css 文件，我们按以上的方法在浏览器中只能修改 css 文件，而不能修改源 scss 文件。</p>
<p> 解决方法是：</p>
<pre><code> 1. 修改 webstorm 的 sass 插件配置

         -<span class="ruby">-no-cache --update <span class="variable">$FileName</span><span class="variable">$:</span><span class="variable">$FileNameWithoutExtension</span><span class="variable">$.</span>css
</span>
     修改为：

         -<span class="ruby">-sourcemap --no-cache --update <span class="variable">$FileName</span><span class="variable">$:</span><span class="variable">$FileNameWithoutExtension</span><span class="variable">$.</span>css
</span>
     这时候 test.scss 在自动编译时不仅会生成 test.css 文件，还会生成 test.css.map 文件

 2. 开启 chrome 的 source map 功能

         打开 dev tools 后，勾选 General-&gt;Enable CSS source maps 
</code></pre><p> 这时候，我们审查 test.html 中的元素，则会看到对应的 test.scss 文件</p>
<p> 但在浏览器中修改 css 属性时，实际上修改的是 test.scss 编译生成的 test.css 文件。</p>
<p> 我们希望直接修改的是 test.scss 文件，这时候点击 dev tools 中的 Source，找到对应的 test.scss 文件修改后 cmd + s 保存即可。</p>
</li>
<li><p>第6点其实有点鸡肋</p>
<p> 目前 source map 能让我们在浏览器中修改 css 属性后保存到对应的 css 文件中。</p>
<p> 而要修改 Sass 文件只能借 Workspace 功能在 Source 面板中修改后保存，但这时候修改的 Sass 文件并不会自动编译为对应的 css 文件。</p>
<p> 在浏览器中修改 Sass 文件保存到本地后，浏览器中的 css 并没有即时改变。</p>
</li>
</ol>
]]></content>
    
    
      <category term="workplace" scheme="http://laispace.github.io/tags/workplace/"/>
    
      <category term="sourcemap" scheme="http://laispace.github.io/tags/sourcemap/"/>
    
      <category term="Tools" scheme="http://laispace.github.io/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nodejs 的 stream 使用指南]]></title>
    <link href="http://laispace.github.io/2014/08/Nodejs-%E7%9A%84-stream-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://laispace.github.io/2014/08/Nodejs-的-stream-使用指南/</id>
    <published>2014-08-28T01:58:22.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用_Stream">使用 Stream</h1>
<p>当我们读取一个文件内容时，可能会这么写：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{
        res.end(data);
    });
});
server.listen(<span class="number">8000</span>);
</code></pre><p>当这个文件 data.txt 非常大时，不仅会占满内存，而且对于网络不好的用户而言体验将非常差。</p>
<p>好在 req 和 res 都是 Stream 对象，我们可以使用 Stream 的方式来写代码：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);
    stream.pipe(res);
});
server.listen(<span class="number">8000</span>);
</code></pre><p>我们使用 fs.createReadStream 创建了一个 Stream 对象，.pipe() 方法会监听对应的 <code>data</code> 和 <code>end</code> 事件。</p>
<p>使用 Stream 的好处在于，我们将 data.txt 分段（chunk）传输到客户端，减轻了网络带宽的压力。</p>
<a id="more"></a>

<h1 id="使用_oppressor_压缩数据">使用 oppressor 压缩数据</h1>
<p>如果客户端支持 gzip 或 deflate 压缩的话，我们就可以使用 oppressor 这个模块来对数据进行压缩后传输：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> oppressor = <span class="built_in">require</span>(<span class="string">'operessor'</span>);
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);
    stream.pipe(oppressor(req)).pipe(res);
});
server.listen(<span class="number">8000</span>);
</code></pre><h1 id="理解_Stream_的基础知识">理解 Stream 的基础知识</h1>
<h2 id="pipe_管道">pipe 管道</h2>
<p>我们可以这么理解 pipe:</p>
<pre><code>src.<span class="keyword">pipe</span>(A).<span class="keyword">pipe</span>(B).<span class="keyword">pipe</span>(dst);            
</code></pre><p>等价于：</p>
<pre><code>src.<span class="keyword">pipe</span>(A);
A.<span class="keyword">pipe</span>(B);
B.<span class="keyword">pipe</span>(dst);
</code></pre><p>即把 src 这个输入交给 A 进行处理后，输出到 B处理，然后把结果输出到 dst。</p>
<h1 id="readable_streams_可读流">readable streams 可读流</h1>
<p>在上述代码中，src 就是一个 readable stream 即可读流。</p>
<p>让我们来创建一个可读流：</p>
<pre><code><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;
<span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;
rs.push(<span class="string">'hello '</span>);
rs.push(<span class="string">'world \n'</span>);
rs.push(<span class="literal">null</span>);
rs.pipe(process.stdout);
</code></pre><p>将这段代码保存到 read0.js 中，然后执行它：</p>
<pre><code>$ node <span class="built_in">read</span>0.js
</code></pre><p>将得到输出：</p>
<pre><code><span class="title">hello</span> world
</code></pre><p>注意 <code>rs.push(null)</code> 用于指明我们对这个可读流写入数据完毕。</p>
<p>在发出 <code>rs.push(null)</code> 指明写入数据完毕之前，我们可以使用 <code>rs.push()</code> 往可读流中继续输入数据。</p>
<p>而有时候我们希望根据特定条件完成可读流的输入，这时候就可以改写 Readable._read() 方法。</p>
<pre><code><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;
<span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;
<span class="keyword">var</span> c = <span class="number">97</span>;
rs._read = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    rs.push(<span class="built_in">String</span>.fromCharCode(c++));
    <span class="keyword">if</span> (c &gt; <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) {
        rs.push(<span class="literal">null</span>);
    }
};
rs.pipe(process.stdout);
</code></pre><p>rs._read() 将从 <code>a</code> 读到 <code>z</code>，然后才停止对可读流的写入。</p>
<p>将这段代码保存到 read1.js 中，然后执行它：</p>
<pre><code>$ node <span class="built_in">read</span>1.js
</code></pre><p>将得到输出：</p>
<pre><code>abcdefghijklmnopqrstuvwxyz
</code></pre><p>注意我们改写了 rs._read() 方法而并没有调用它，因为当条件 <code>c &gt; &#39;z&#39;.charCodeAt(0)</code> 成立时，我们使用 <code>rs.push(null)</code> 指明可读流写入数据完毕。</p>
<p>为了证明输出 <code>a-z</code> 的过程中调用了 <code>rs._read()</code> 多次，我们编写：</p>
<pre><code><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;
<span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;
<span class="keyword">var</span> c = <span class="number">97</span> - <span class="number">1</span>;
rs._read = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">if</span> (c &gt;= <span class="string">'z'</span>.charCodeAt(<span class="number">0</span>)) {
        <span class="keyword">return</span> rs.push(<span class="literal">null</span>);
    }
    setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        rs.push(<span class="built_in">String</span>.fromCharCode(++c));
    }, <span class="number">100</span>);
};
rs.pipe(process.stdout);
process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="built_in">console</span>.error(<span class="string">'\n_read() called '</span> + (c - <span class="number">97</span>) + <span class="string">' times'</span>);
});
process.stdout.on(<span class="string">'error'</span>, process.exit);
</code></pre><p>将这段代码保存到 read2.js 中，然后执行它：</p>
<pre><code>$ node <span class="built_in">read</span>2.js
</code></pre><p>将得到输出：</p>
<pre><code>abcdefghijklmnopqrstuvwxyz
_<span class="built_in">read</span>() called <span class="number">25</span> times
</code></pre><p>而如果我们执行：</p>
<pre><code>$ node <span class="built_in">read</span>2.js | head -c5
</code></pre><p>这里的 <code>| head -c5</code> 为 *nix 命令，表示只输出 5 个字节的数据，这时候将得到输出：</p>
<pre><code>abcde
_<span class="built_in">read</span>() called <span class="number">5</span> times
</code></pre><p>有了 <code>| head -c5</code> 这个参数，当输出了 5 个字节的数据后，操作系统发出 SIFPIPE 信号，中断进程，process.stdout 产生错误 EPIPE。</p>
<p>接着 <code>process.stdout</code> 捕获到错误，触发 <code>exit</code> 事件，所以这时候记录下 <code>rs._read()</code> 的执行次数为 5。</p>
<h2 id="使用_readable_stream_可读流">使用 readable stream 可读流</h2>
<p>直接使用可读流非常简单：</p>
<pre><code>process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> buf = process.stdin.read();
    <span class="built_in">console</span>.dir(buf);
});
</code></pre><p>将这段代码保存到 consume0.js 中，然后执行它：</p>
<pre><code>$ (<span class="keyword">echo</span> <span class="keyword">abc</span>; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> def; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> ghi) | node consume0.js 
</code></pre><p>我们在命令行中输出一些数据当做 consume0.js 的输入，将得到输出：</p>
<pre><code>&lt;Buffer <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">0</span><span class="operator">a</span>&gt;
&lt;Buffer <span class="number">64</span> <span class="number">65</span> <span class="number">66</span> <span class="number">0</span><span class="operator">a</span>&gt;
&lt;Buffer <span class="number">67</span> <span class="number">68</span> <span class="number">69</span> <span class="number">0</span><span class="operator">a</span>&gt;
<span class="constant">null</span>
</code></pre><p>当 <code>process.stdin</code> 监听到有数据传入时，我们就可以使用 <code>process.stdin.read()</code> 读取到这些数据。</p>
<p>我们看到了输出中有 <code>null</code> 是因为当数据读取完毕时，<code>process.stdin.read()</code> 将返回 <code>null</code>。</p>
<p>而如果我们给 <code>process.std.read(n)</code> 传入了参数 <code>n</code> 时，将得到 n 字节的数据输出：</p>
<pre><code>process.stdin.on(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> buf = process.stdin.read(<span class="number">3</span>);
    <span class="built_in">console</span>.dir(buf);
});
</code></pre><p>将这段代码保存到 consume1.js 中，然后执行它：</p>
<pre><code>$ (<span class="keyword">echo</span> <span class="keyword">abc</span>; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> def; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> ghi) | node consume1.js 
</code></pre><p>我们在命令行中输出一些数据当做 consume1.js 的输入，但给 <code>process.stdin.read(3)</code> 传入了参数数字 3，将得到输出：</p>
<pre><code><span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">61</span> <span class="attribute">62</span> <span class="attribute">63</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">0a</span> <span class="attribute">64</span> <span class="attribute">65</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">66</span> <span class="attribute">0a</span> <span class="attribute">67</span>&gt;</span>
</code></pre><p>注意我们并没有得到 <code>abc</code> <code>def</code> <code>ghi</code> 对应的完整输出，因为我们限制了读取的字节数为 3，所以剩下的数据保存在了内存中。</p>
<p>我们能需要读出剩余的数据，改写代码为：</p>
<pre><code>process.stdin.<span class="keyword">on</span>(<span class="string">'readable'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    var buf = process.stdin.<span class="keyword">read</span>(<span class="number">3</span>);
    console.dir(buf);
    process.stdin.<span class="keyword">read</span>(<span class="number">0</span>);
});
</code></pre><p>将这段代码保存到 consume2.js 中，然后执行它：</p>
<pre><code>$ (<span class="keyword">echo</span> <span class="keyword">abc</span>; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> def; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> ghi) | node consume2.js 
</code></pre><p>我们在命令行中输出一些数据当做 consume2.js 的输入，读完 3 个字节数据后，继续读取。将得到输出：</p>
<pre><code><span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">61</span> <span class="attribute">62</span> <span class="attribute">63</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">0a</span> <span class="attribute">64</span> <span class="attribute">65</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">66</span> <span class="attribute">0a</span> <span class="attribute">67</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">68</span> <span class="attribute">69</span> <span class="attribute">0a</span>&gt;</span>
</code></pre><h2 id="writable_streams_可写流">writable streams 可写流</h2>
<p>只需要使用 Writable._write() 即可创建 writable strearm 可写流：</p>
<pre><code><span class="keyword">var</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;
<span class="keyword">var</span> ws = <span class="keyword">new</span> Writable();
ws._write = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, enc, callback)</span> </span>{
    <span class="built_in">console</span>.dir(chunk);
    callback();
};
process.stdin.pipe(ws);
</code></pre><p>将这段代码保存到 write0.js 中，然后执行它：</p>
<pre><code>$ (<span class="keyword">echo</span> hello; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> world) | node write0.js 
</code></pre><p>将得到输出：</p>
<pre><code>&lt;<span class="constant">Buffer</span> <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f 0a&gt;
<span class="input"><span class="prompt">&lt;Buffer 77 6f 72 6c 64 0a&gt;</span> hello world    </span>
</code></pre><p>第一个参数 <code>chunk</code> 表示将要写入的数据。</p>
<p>第二个参数 <code>enc</code> 表示编码，如果 chunk 为字符串，编码类型则为字符串。</p>
<p>除非我们在创建可写流时指定了 <code>Writable({ decodeStrings: false })</code>，否则数据将会被转化为 Buffer 类型。</p>
<p>第三个参数 <code>callback</code> 表示回调函数。</p>
<h2 id="使用_writable_stream_可写流">使用 writable stream 可写流</h2>
<p>直接使用 <code>.write()</code> 方法就即可使用可写流：</p>
<pre><code>process.stdout.<span class="keyword">write</span>(<span class="string">'hello world \n'</span>);
</code></pre><p>我们可以将文件内容创建为可写流：</p>
<pre><code>var fs = require(<span class="string">'fs'</span>);
var <span class="keyword">ws</span> = fs.createWriteStream(<span class="string">'message.txt'</span>);
<span class="keyword">ws</span>.<span class="keyword">write</span>(<span class="string">'hello '</span>);
setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">ws</span>.end(<span class="string">'world \n'</span>);
}, <span class="number">1000</span>);
</code></pre><p>将这段代码保存到 writing1.js 中，然后执行它：</p>
<pre><code><span class="variable">$ </span>node writing1.js 
</code></pre><p>注意这里用 <code>ws.end()</code> 指明我们写入数据完毕，数据将被写入到 <code>message.txt</code> 中：</p>
<pre><code>$ cat <span class="class"><span class="keyword">message</span>.<span class="title">txt</span>
hello world</span>
</code></pre><h2 id="transform_转换">transform 转换</h2>
<p>Transform streams 即转换流，是用于转换输入为输出的可读/写的双工流。</p>
<h2 id="duplex_双工">duplex 双工</h2>
<p>Duplex streams 即双工流，流的两端都可进行读或写：</p>
<pre><code>A.<span class="keyword">pipe</span>(B).<span class="keyword">pipe</span>(A);
</code></pre><h2 id="classic_streams_经典流">classic streams 经典流</h2>
<p>Classic streams 即经典流，最早出现在 node v0.4 中。</p>
<p>当一个流注册了 <code>data</code> 监听函数时，就会转换到静电流模式，这时候可以使用旧的 API 对流进行操作。</p>
<h3 id="classic_readable_streams_经典可读流">classic readable streams 经典可读流</h3>
<p>经典可读流只有 <code>data</code> 和 <code>end</code> 事件触发器，分别用来接收数据和停止接收数据。</p>
<p><code>.pipe()</code> 通过判断 <code>stream.readable</code> 的值来检查一个经典流是否可读：</p>
<pre><code><span class="keyword">var</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);
<span class="keyword">var</span> stream = <span class="keyword">new</span> Stream;
stream.readable = <span class="literal">true</span>;
<span class="keyword">var</span> c = <span class="number">64</span>;
<span class="keyword">var</span> iv = setInterval(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">if</span> (++c &gt;= <span class="number">75</span>) {
        clearInterval(iv);
        stream.emit(<span class="string">'end'</span>);
    }
    <span class="keyword">else</span> stream.emit(<span class="string">'data'</span>, <span class="built_in">String</span>.fromCharCode(c));
}, <span class="number">100</span>);
stream.pipe(process.stdout);
</code></pre><p>将这段代码保存到 classic0.js 中，然后执行它：</p>
<pre><code><span class="variable">$ </span>node classic<span class="number">0</span>.js 
</code></pre><p>将得到输出：</p>
<pre><code>ABCDEFGHIJ
</code></pre><p>上面这段代码中的 <code>.emit</code> 用于触发 <code>data</code> 和 <code>end</code> 事件。</p>
<p>为了从命令行中得到输入，我们使用 <code>on</code> 对这两个事件进行监听：</p>
<pre><code>process.stdin.<span class="keyword">on</span>(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(buf)</span> {</span>
    console.<span class="built_in">log</span>(buf);
});
process.stdin.<span class="keyword">on</span>(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    console.<span class="built_in">log</span>(<span class="string">'__END__'</span>);
});
</code></pre><p>将这段代码保存到 classic1.js 中，然后执行它：</p>
<pre><code><span class="variable">$ </span>node classic1.js 
</code></pre><p>我们接着输入 <code>hello world</code> 和 <code>hello xiaolai</code>将分别得到输出：</p>
<pre><code>hello world
&lt;Buffer <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">20</span> <span class="number">77</span> <span class="number">6f</span> <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span> <span class="number">0</span>a&gt;
hello xiaolai
&lt;Buffer <span class="number">68</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6f</span> <span class="number">20</span> <span class="number">78</span> <span class="number">69</span> <span class="number">61</span> <span class="number">6f</span> <span class="number">6</span>c <span class="number">61</span> <span class="number">69</span> <span class="number">0</span>a&gt;
</code></pre><p>或者在运行 classic1.js 时就传入数据：</p>
<pre><code>$ (<span class="keyword">echo</span> hello; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> world) | node classic1.js 
</code></pre><p>将得到输出：</p>
<pre><code><span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">68</span> <span class="attribute">65</span> <span class="attribute">6c</span> <span class="attribute">6c</span> <span class="attribute">6f</span> <span class="attribute">0a</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">77</span> <span class="attribute">6f</span> <span class="attribute">72</span> <span class="attribute">6c</span> <span class="attribute">64</span> <span class="attribute">0a</span>&gt;</span>
__END__
</code></pre><p>注意 <code>data</code> 和 <code>end</code> 事件我们可以不再使用了，毕竟这是老旧的 API 了。</p>
<p>我们可以使用一些模块比如 <a href="https://www.npmjs.org/package/through" target="_blank" rel="external">through</a> 来处理流：</p>
<pre><code><span class="keyword">var</span> through = <span class="built_in">require</span>(<span class="string">'through'</span>);
process.stdin.pipe(through(write, end));
<span class="function"><span class="keyword">function</span> <span class="title">write</span> <span class="params">(buf)</span> </span>{
    <span class="built_in">console</span>.log(buf);
}
<span class="function"><span class="keyword">function</span> <span class="title">end</span> <span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="string">'__END__'</span>);
}
</code></pre><p>将这段代码保存到 through.js 中，然后执行它：</p>
<pre><code>$ (<span class="keyword">echo</span> hello; <span class="keyword">sleep</span> <span class="number">1</span>; <span class="keyword">echo</span> world) | node through.js
</code></pre><p>将得到输出：</p>
<pre><code><span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">68</span> <span class="attribute">65</span> <span class="attribute">6c</span> <span class="attribute">6c</span> <span class="attribute">6f</span> <span class="attribute">0a</span>&gt;</span>
<span class="tag">&lt;<span class="title">Buffer</span> <span class="attribute">77</span> <span class="attribute">6f</span> <span class="attribute">72</span> <span class="attribute">6c</span> <span class="attribute">64</span> <span class="attribute">0a</span>&gt;</span>
__END__
</code></pre><p>也可以使用 <a href="https://www.npmjs.org/package/concat-stream" target="_blank" rel="external">concat-stream</a> 模块来进行操作：</p>
<pre><code><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'concat-stream'</span>);
process.stdin.pipe(concat(<span class="function"><span class="keyword">function</span> <span class="params">(body)</span> </span>{
    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(body));
}));
</code></pre><p>将这段代码保存到 concat-stream.js 中，然后执行它：</p>
<pre><code>$ echo '{<span class="string">"hello"</span>:<span class="string">"world"</span>}' <span class="string">| node concat-stream.js </span>
</code></pre><p>将得到输出：</p>
<pre><code><span class="rules">{ <span class="rule"><span class="attribute">hello</span>:<span class="value"> <span class="string">'world'</span> </span></span></span>}
</code></pre><p>经典的可读流具有 <code>.pause()</code> 和 <code>.resume()</code> 逻辑对暂停、恢复读取数据进行支持。</p>
<p>如果我们要使用这些操作的话，最好通过 <a href="https://www.npmjs.org/package/through" target="_blank" rel="external">through</a> 模块来完成。</p>
<h3 id="classic_writable_streams_经典可写流">classic writable streams 经典可写流</h3>
<p>经典可写流很简单，只需要定义 <code>.write(buf)</code> <code>.end(buf)</code> <code>.destroy()</code> 即可。</p>
<p>注意 <code>.end(buf)</code> 可能不包含参数，即 相当于 <code>stream.write(buf); stream.end()</code> 指明写入流完毕。</p>
<h2 id="阅读更多">阅读更多</h2>
<ul>
<li><a href="http://nodejs.org/docs/latest/api/stream.html#stream_stream" target="_blank" rel="external">流的官方文档</a></li>
<li>使用 <a href="https://npmjs.org/package/readable-stream" target="_blank" rel="external">readable-stream</a> 模块兼容 v0.8 及以下版本的 node，只需要用 <code>require(&#39;readable-stream&#39;)</code> 取代 <code>require(&#39;stream&#39;)</code> 来操作即可。</li>
</ul>
<h2 id="built-in_streams_内置的流">built-in streams 内置的流</h2>
<p>这些流是 node 中内置的流。</p>
<p>！！！未完待续 <a href="https://github.com/substack/stream-handbook#built-in-streams" target="_blank" rel="external">https://github.com/substack/stream-handbook#built-in-streams</a></p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><p><a href="http://nodejs.org/api/stream.html#stream_readable_read_size_1" target="_blank" rel="external">Implement readable._read(size), but do NOT call it directly</a></p>
</li>
<li><p><a href="http://nodejs.org/api/stream.html#stream_readable_push_chunk_encoding" target="_blank" rel="external">readable.push(chunk, [encoding]) should be called by Readable implementors, NOT by consumers of Readable streams.</a></p>
</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h1 id="使用_Stream">使用 Stream</h1>
<p>当我们读取一个文件内容时，可能会这么写：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{
        res.end(data);
    });
});
server.listen(<span class="number">8000</span>);
</code></pre><p>当这个文件 data.txt 非常大时，不仅会占满内存，而且对于网络不好的用户而言体验将非常差。</p>
<p>好在 req 和 res 都是 Stream 对象，我们可以使用 Stream 的方式来写代码：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
    <span class="keyword">var</span> stream = fs.createReadStream(__dirname + <span class="string">'/data.txt'</span>);
    stream.pipe(res);
});
server.listen(<span class="number">8000</span>);
</code></pre><p>我们使用 fs.createReadStream 创建了一个 Stream 对象，.pipe() 方法会监听对应的 <code>data</code> 和 <code>end</code> 事件。</p>
<p>使用 Stream 的好处在于，我们将 data.txt 分段（chunk）传输到客户端，减轻了网络带宽的压力。</p>
]]></summary>
    
      <category term="stream" scheme="http://laispace.github.io/tags/stream/"/>
    
      <category term="through" scheme="http://laispace.github.io/tags/through/"/>
    
      <category term="concat-stream" scheme="http://laispace.github.io/tags/concat-stream/"/>
    
      <category term="readable" scheme="http://laispace.github.io/tags/readable/"/>
    
      <category term="writeable" scheme="http://laispace.github.io/tags/writeable/"/>
    
      <category term="Node" scheme="http://laispace.github.io/categories/Node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[bytewiser 练习]]></title>
    <link href="http://laispace.github.io/2014/08/bytewiser-%E7%BB%83%E4%B9%A0/"/>
    <id>http://laispace.github.io/2014/08/bytewiser-练习/</id>
    <published>2014-08-23T06:04:01.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>bytewiser 是 nodeschool.io 出品的nodejs入门练习项目</p>
</blockquote>
<h1 id="bytewiser-exercise-1">bytewiser-exercise-1</h1>
<p>Write a node program that prints a buffer object containing the string “bytewiser” using console.log.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = <span class="string">'bytewiser'</span>;</div><div class="line">var <span class="keyword">buffer</span> = <span class="keyword">new</span> Buffer(str);</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">buffer</span>);</div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-2">bytewiser-exercise-2</h1>
<p>Given an unknown number of bytes passed via process.argv, create a buffer from them and output a hexadecimal encoded representation of the buffer.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var array = process.<span class="built_in">argv</span>.slice(<span class="number">2</span>);</div><div class="line">var <span class="keyword">buffer</span> = <span class="keyword">new</span> Buffer(array);</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">buffer</span>.toString(<span class="string">'hex'</span>));</div><div class="line"></div><div class="line">// 官方答案</div><div class="line">// var bytes = process.<span class="built_in">argv</span>.slice(<span class="number">2</span>).<span class="built_in">map</span>(<span class="function"><span class="keyword">function</span><span class="params">(arg)</span> { <span class="title">return</span> <span class="title">parseInt</span><span class="params">(arg)</span> })</span></div><div class="line">// console.<span class="built_in">log</span>(<span class="keyword">new</span> Buffer(bytes).toString(<span class="string">'hex'</span>))</div></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="bytewiser-exercise-3">bytewiser-exercise-3</h1>
<p>Write a program that takes the first buffer written to <code>process.stdin</code>,<br>updates all instances of . with ! and then logs out the updated buffer object.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听用户输入，将 . 替换为 ! 输出</span></div><div class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(buffer)</span> </span>{</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buffer.length; i++) {</div><div class="line">    <span class="comment">// 0x2e 对应为 .</span></div><div class="line">    <span class="comment">// 0x2e 对应为 !</span></div><div class="line">    <span class="keyword">if</span> (buffer[i] === <span class="number">0x2e</span>) buffer[i] = <span class="number">0x21</span></div><div class="line">  }</div><div class="line">  <span class="built_in">console</span>.log(buffer);</div><div class="line">});</div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-4">bytewiser-exercise-4</h1>
<p>The argument given to you from <code>process.argv[2]</code> will be a path to a file.<br>Read this file and split it by newline characters (‘\n’). You should log one Buffer per line.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> file = process.argv[<span class="number">2</span>];</div><div class="line">fs.readFile(file, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (err) {</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> <span class="keyword">array</span> = data.toString().split(<span class="string">'\n'</span>);</div><div class="line">    <span class="keyword">var</span> len = <span class="keyword">array</span>.length;</div><div class="line">    <span class="keyword">var</span> buffer;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {</div><div class="line">        buffer = <span class="keyword">new</span> Buffer(<span class="keyword">array</span>[i]);</div><div class="line">        console.log(buffer);</div><div class="line">    };</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// 官方答案</span></div><div class="line"><span class="comment">// var fs = require('fs')</span></div><div class="line"><span class="comment">// var file = fs.readFileSync(process.argv[2])</span></div><div class="line"><span class="comment">// var offset = 0</span></div><div class="line"><span class="comment">// for (var i = 0; i &lt; file.length; i++) {</span></div><div class="line"><span class="comment">//   if (file[i] === 10) {</span></div><div class="line"><span class="comment">//     console.log(file.slice(offset, i))</span></div><div class="line"><span class="comment">//     i++</span></div><div class="line"><span class="comment">//     offset = i</span></div><div class="line"><span class="comment">//   }</span></div><div class="line"><span class="comment">// }</span></div><div class="line"><span class="comment">// console.log(file.slice(offset, i))</span></div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-5">bytewiser-exercise-5</h1>
<p>Write a program that combines all of the buffers from <code>process.stdin</code><br>and then writes the single big buffer out to the console.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffers = [];</div><div class="line">process.<span class="literal">stdin</span>.on('data', function (chunk) {</div><div class="line">    <span class="keyword">var</span> buffer = new <span class="type">Buffer</span>(chunk);</div><div class="line">    buffers.push(buffer);</div><div class="line">});</div><div class="line">process.<span class="literal">stdin</span>.on('<span class="keyword">end</span>', function () {</div><div class="line">    <span class="keyword">var</span> <span class="literal">result</span> = <span class="type">Buffer</span>.concat(buffers);</div><div class="line">    console.log(<span class="literal">result</span>);</div><div class="line">});</div><div class="line"></div><div class="line">// 官方答案</div><div class="line">// <span class="keyword">var</span> buffers = [];</div><div class="line">// process.<span class="literal">stdin</span>.on('readable', function() {</div><div class="line">//   <span class="keyword">var</span> chunk = process.<span class="literal">stdin</span>.read();</div><div class="line">//   <span class="keyword">if</span> (chunk !== null) {</div><div class="line">//     buffers.push(chunk);</div><div class="line">//   }</div><div class="line">// });</div><div class="line">// process.<span class="literal">stdin</span>.on('<span class="keyword">end</span>', function() {</div><div class="line">//   console.log(<span class="type">Buffer</span>.concat(buffers));</div><div class="line">// });</div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-6">bytewiser-exercise-6</h1>
<p>Read the first buffer from process.stdin, copy all bytes into a<br>Uint8Array and then log out a JSON stringified representation of the typed array.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">process.<span class="literal">stdin</span>.on('data', function (chunk) {</div><div class="line">    <span class="keyword">var</span> uInt8array = new <span class="type">Uint8Array</span>(chunk);</div><div class="line">    <span class="keyword">var</span> <span class="literal">result</span> = <span class="type">JSON</span>.stringify(uInt8array);</div><div class="line">    console.log(<span class="literal">result</span>);</div><div class="line">});</div><div class="line"></div><div class="line">// 官方答案</div><div class="line">// process.<span class="literal">stdin</span>.once('data', function(buff) {</div><div class="line">//   <span class="keyword">var</span> ui8 = new <span class="type">Uint8Array</span>(buff)</div><div class="line">//   console.log(<span class="type">JSON</span>.stringify(ui8))</div><div class="line">// })</div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-7">bytewiser-exercise-7</h1>
<p>Take the integer from process.argv[2] and write it as the first<br>element in a single element Uint32Array. Then create a Uint16Array from the Array<br>Buffer of the Uint32Array and log out to the console the JSON stringified version<br>of the Uint16Array.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="type">int</span> = parseInt(process.argv[<span class="number">2</span>]);</div><div class="line"><span class="keyword">var</span> uint32array = new <span class="type">Uint32Array</span>(<span class="number">1</span>);</div><div class="line">uint32array[<span class="number">0</span>] = <span class="type">int</span>;</div><div class="line"><span class="keyword">var</span> uint16array = new <span class="type">Uint16Array</span>(uint32array.buffer);</div><div class="line"><span class="keyword">var</span> <span class="literal">result</span> = <span class="type">JSON</span>.stringify(uint16array);</div><div class="line">console.log(<span class="literal">result</span>);</div><div class="line"></div><div class="line">// 官方答案</div><div class="line">// <span class="keyword">var</span> num = +process.argv[<span class="number">2</span>]</div><div class="line">// <span class="keyword">var</span> ui32 = new <span class="type">Uint32Array</span>(<span class="number">1</span>)</div><div class="line">// ui32[<span class="number">0</span>] = num</div><div class="line">// <span class="keyword">var</span> ui16 = new <span class="type">Uint16Array</span>(ui32.buffer)</div><div class="line">// console.log(<span class="type">JSON</span>.stringify(ui16))</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<blockquote>
<p>bytewiser 是 nodeschool.io 出品的nodejs入门练习项目</p>
</blockquote>
<h1 id="bytewiser-exercise-1">bytewiser-exercise-1</h1>
<p>Write a node program that prints a buffer object containing the string “bytewiser” using console.log.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = <span class="string">'bytewiser'</span>;</div><div class="line">var <span class="keyword">buffer</span> = <span class="keyword">new</span> Buffer(str);</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">buffer</span>);</div></pre></td></tr></table></figure>

<h1 id="bytewiser-exercise-2">bytewiser-exercise-2</h1>
<p>Given an unknown number of bytes passed via process.argv, create a buffer from them and output a hexadecimal encoded representation of the buffer.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var array = process.<span class="built_in">argv</span>.slice(<span class="number">2</span>);</div><div class="line">var <span class="keyword">buffer</span> = <span class="keyword">new</span> Buffer(array);</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">buffer</span>.toString(<span class="string">'hex'</span>));</div><div class="line"></div><div class="line">// 官方答案</div><div class="line">// var bytes = process.<span class="built_in">argv</span>.slice(<span class="number">2</span>).<span class="built_in">map</span>(<span class="function"><span class="keyword">function</span><span class="params">(arg)</span> { <span class="title">return</span> <span class="title">parseInt</span><span class="params">(arg)</span> })</span></div><div class="line">// console.<span class="built_in">log</span>(<span class="keyword">new</span> Buffer(bytes).toString(<span class="string">'hex'</span>))</div></pre></td></tr></table></figure>

]]></summary>
    
      <category term="bytewiser" scheme="http://laispace.github.io/tags/bytewiser/"/>
    
      <category term="buffer" scheme="http://laispace.github.io/tags/buffer/"/>
    
      <category term="Node" scheme="http://laispace.github.io/categories/Node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sass 学习笔记]]></title>
    <link href="http://laispace.github.io/2014/08/Sass-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://laispace.github.io/2014/08/Sass-学习笔记/</id>
    <published>2014-08-13T09:40:49.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装_Sass">安装 Sass</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="char">$ </span>gem install sass</div><div class="line">// 或</div><div class="line"><span class="char">$ </span>sudo gem install sass </div><div class="line"></div><div class="line">// 查看 sass 版本</div><div class="line"><span class="char">$ </span>sass -v</div></pre></td></tr></table></figure>

<h1 id="快速入门_sass_语法">快速入门 sass 语法</h1>
<h2 id="Variables_|_变量">Variables | 变量</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// test.scss</span></div><div class="line"><span class="variable">$lai-font</span><span class="value">: Roboto, sans-serif;</span></div><div class="line"><span class="variable">$lai-color</span><span class="value">: <span class="hexcolor">#eee</span>;</span></div><div class="line"></div><div class="line"><span class="tag">body</span> {</div><div class="line">  <span class="attribute">color</span><span class="value">: <span class="variable">$lai-color</span>;</span></div><div class="line">  <span class="attribute">font-family</span><span class="value">: <span class="variable">$lai-font</span>;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Nesting_|_嵌套">Nesting | 嵌套</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">nav</span> {</div><div class="line">  <span class="tag">ul</span> {</div><div class="line">    <span class="attribute">margin</span><span class="value">: <span class="number">0</span> auto;</span></div><div class="line">    <span class="attribute">padding</span><span class="value">: <span class="number">0</span>;</span></div><div class="line">    <span class="attribute">list-style</span><span class="value">: <span class="number">0</span>;</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="tag">li</span> {</div><div class="line">    <span class="attribute">display</span><span class="value">: inline-block;</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="tag">a</span> {</div><div class="line">    <span class="attribute">display</span><span class="value">: block;</span></div><div class="line">    <span class="attribute">padding</span><span class="value">: <span class="number">5px</span> <span class="number">10px</span>;</span></div><div class="line">    <span class="attribute">text-decoration</span><span class="value">: none;</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Partials_|_模板">Partials | 模板</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// _reset.scss</span></div><div class="line"><span class="tag">html</span>,</div><div class="line"><span class="tag">body</span>,</div><div class="line"><span class="tag">ul</span>,</div><div class="line"><span class="tag">ol</span> {</div><div class="line">  <span class="attribute">margin</span><span class="value">: <span class="number">0</span>;</span></div><div class="line">  <span class="attribute">padding</span><span class="value">: <span class="number">0</span>;</span></div><div class="line"></div><div class="line">}</div><div class="line"><span class="comment">// 使用 partial</span></div><div class="line"><span class="comment">// base.scss</span></div><div class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="string">'reset'</span><span class="preprocessor"></span></span></div><div class="line">body {</div><div class="line">  backgrount<span class="value">: <span class="hexcolor">#333</span>;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Mixins_|_混入">Mixins | 混入</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">mixin</span><span class="preprocessor"> border-radius</span>(<span class="variable">$radius</span>) {</span></div><div class="line">  -webkit-<span class="attribute">border-radius</span><span class="value">: <span class="variable">$radius</span>;</span></div><div class="line">     -moz-<span class="attribute">border-radius</span><span class="value">: <span class="variable">$radius</span>;</span></div><div class="line">      -ms-<span class="attribute">border-radius</span><span class="value">: <span class="variable">$radius</span>;</span></div><div class="line">          <span class="attribute">border-radius</span><span class="value">: <span class="variable">$radius</span>;</span></div><div class="line">}</div><div class="line"><span class="comment">// 使用 mixin</span></div><div class="line"><span class="class">.box</span> {</div><div class="line">  <span class="at_rule">@<span class="keyword">include</span><span class="preprocessor"> border-radius</span>(<span class="number">10px</span>);</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Inheritance_|_继承">Inheritance | 继承</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class">.message</span> {</div><div class="line">  <span class="attribute">border</span><span class="value">: <span class="number">1px</span> solid <span class="hexcolor">#ccc</span>;</span></div><div class="line">  <span class="attribute">padding</span><span class="value">: <span class="number">10px</span>;</span></div><div class="line">  <span class="attribute">color</span><span class="value">: <span class="hexcolor">#333</span>;</span></div><div class="line">}</div><div class="line"><span class="class">.success</span> {</div><div class="line">  <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .message</span>;</span></div><div class="line">  <span class="attribute">border-color</span><span class="value">: green;</span></div><div class="line">}</div><div class="line"><span class="class">.error</span> {</div><div class="line">  <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .message</span>;</span></div><div class="line">  <span class="attribute">border-color</span><span class="value">: red;</span></div><div class="line">}</div><div class="line"><span class="class">.warning</span> {</div><div class="line">  <span class="at_rule">@<span class="keyword">extend</span><span class="preprocessor"> .message</span>;</span></div><div class="line">  <span class="attribute">border-color</span><span class="value">: yellow;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Operators_|_运算符">Operators | 运算符</h2>
<p>.container {<br>  width: 100%;<br>}<br>article[role=”main”] {<br>  float: left;<br>  width: 600px / 960px <em> 100%;<br>}<br>article[role=”sub”] {<br>  float: right;<br>  width: 300px / 960px </em> 100%;<br>}</p>
<h1 id="编译_-scss_为_-css">编译 .scss 为 .css</h1>
<p>nested：嵌套缩进的css代码，它是默认值。<br>　   　<br>expanded：没有缩进的、扩展的css代码。<br>　   　<br>compact：简洁格式的css代码。<br>　　<br>compressed：压缩后的css代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 编译风格默认为 --style nested</div><div class="line">$ sass <span class="keyword">test</span>.scss <span class="keyword">test</span>.css</div><div class="line">// 编译风格设置为 --style compressed</div><div class="line">$ sass --style compassed <span class="keyword">test</span>.scss <span class="keyword">test</span>.css</div><div class="line"></div><div class="line">// 查看编译后的 <span class="keyword">test</span>.css    </div><div class="line">$ cat <span class="keyword">test</span>.css</div></pre></td></tr></table></figure>

<h1 id="监听文件变化">监听文件变化</h1>
<p>一旦某个文件/目录发生变化，Sass 就自动编译出新的版本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 监听文件</div><div class="line">$ sass --watch test.<span class="keyword">scs</span><span class="variable">s:test</span>.css</div><div class="line">// 监听目录，一旦 src/scss 下有文件发生变化，就编译到 dist/css 目录</div><div class="line">$ sass --watch src/<span class="keyword">scs</span><span class="variable">s:dist</span>/css</div></pre></td></tr></table></figure>

<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="http://sass-lang.com/guide" target="_blank" rel="external">Sass 官网</a></li>
<li><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html" target="_blank" rel="external">Sass 文档</a></li>
</ul>
]]></content>
    
    
      <category term="Node" scheme="http://laispace.github.io/categories/Node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS属性扫盲笔记]]></title>
    <link href="http://laispace.github.io/2014/08/CSS3%E5%B1%9E%E6%80%A7%E6%89%AB%E7%9B%B2%E7%AC%94%E8%AE%B0/"/>
    <id>http://laispace.github.io/2014/08/CSS3属性扫盲笔记/</id>
    <published>2014-08-13T09:40:49.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>:before 和 ::before 的区别</li>
</ul>
<p>单冒号表示 CSS3 伪类，双冒号表示 CSS3 伪元素<br>双冒号是 CSS3 新引入的属性, 而要兼容 IE8- 则需要使用单冒号<br>不需要兼容 IE8- 则可以放心的使用双冒号</p>
<ul>
<li>-webkit-appearance 设置如何显示元素的外观</li>
</ul>
<p><a href="http://ued.ctrip.com/webkitcss/demo/appearance.html" target="_blank" rel="external">http://ued.ctrip.com/webkitcss/demo/appearance.html</a></p>
<ul>
<li>-webkit-touch-callout 设置如何显示一个可触摸目标的样式</li>
</ul>
<p><a href="http://css-infos.net/property/-webkit-touch-callout" target="_blank" rel="external">http://css-infos.net/property/-webkit-touch-callout</a></p>
<ul>
<li>-webkit-user-select 设置是否可以选择元素内容</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/user-select.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/user-select.html</a></p>
<ul>
<li>-webkit-user-drag 设置是否可以拖动元素内容</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/user-drag.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/user-drag.html</a></p>
<ul>
<li>-webkit-flex 设置伸缩布局</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/flex.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/flex.html</a></p>
<p>安卓 4.4+ 才支持, 伤不起啊…</p>
<ul>
<li>-webkit-tap-highlight-color 设置元素的点击高亮颜色</li>
</ul>
<p><a href="http://ued.ctrip.com/webkitcss/prop/tap-highlight-color.html" target="_blank" rel="external">http://ued.ctrip.com/webkitcss/prop/tap-highlight-color.html</a> </p>
<pre><code><span class="comment">/* 设置为透明, 则禁用该属性 */</span>
<span class="tag">-webkit-tap-highlight-color</span>: <span class="tag">transparent</span>;

<span class="comment">/* 场景: callout 和 hightlite 配合使用*/</span>
<span class="class">.nohighlight</span> <span class="rules">{
  <span class="rule"><span class="attribute">-webkit-touch-callout</span>:<span class="value"> none</span></span>;
  <span class="rule"><span class="attribute">-webkit-tap-highlight-color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;
<span class="rule">}</span></span>
</code></pre><ul>
<li>以下属性与 display: -webkit-box; 配合使用</li>
</ul>
<p>-webkit-box-sizing 设置对象的盒模型组成模式</p>
<pre><code>    <span class="class">.selector</span> {
        <span class="attribute">width</span><span class="value">: <span class="number">100px</span>;</span>
        <span class="attribute">margin</span><span class="value">: <span class="number">10px</span>;</span>
        <span class="attribute">padding</span><span class="value">: <span class="number">10px</span>;</span>
        <span class="attribute">border</span><span class="value">: <span class="number">1px</span> solid <span class="hexcolor">#eee</span>;</span>
        <span class="comment">// 设置为 border-box, 则 width 包含了 padding 和 border </span>
        -webkit-<span class="attribute">box-sizing</span><span class="value">: border-box;</span>
    }
</code></pre><p>-webkit-box-flex 设置弹性盒模型对象的子元素如何分配<em>剩余</em>空间</p>
<pre><code><span class="class">.selector-parent</span> <span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150px</span></span></span>;
    <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-box</span></span>;
<span class="rule">}</span></span>
<span class="class">.selector-child-fixed</span> <span class="rules">{
    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50px</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.selector-child-flex-1</span> <span class="rules">{
    <span class="comment">/* 占 40px */</span>
    <span class="rule"><span class="attribute">-webkit-box-flex</span>:<span class="value"> <span class="number">2</span></span></span>;
<span class="rule">}</span></span>
<span class="class">.selector-child-flex-2</span> <span class="rules">{
    <span class="comment">/*占 60px */</span>
    <span class="rule"><span class="attribute">-webkit-box-flex</span>:<span class="value"> <span class="number">3</span></span></span>;
<span class="rule">}</span></span>
</code></pre><ul>
<li>-webkit-box-orient 设置弹性盒模型对象的子元素的排列方式</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-orient.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-orient.html</a></p>
<ul>
<li>-webkit-box-pack 设置弹性盒模型对象的子元素的对齐方式</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-pack.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-pack.html</a></p>
<ul>
<li>-webkit-box-align 设置弹性盒模型对象的子元素的对齐方式</li>
</ul>
<p><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-align.html" target="_blank" rel="external">http://ued.ctrip.com/blog/wp-content/webkitcss/prop/box-align.html</a></p>
<ul>
<li>-webkit-line-clamp 设置块元素显示文本的行数</li>
</ul>
<p><a href="http://www.css88.com/webkit/-webkit-line-clamp/" target="_blank" rel="external">http://www.css88.com/webkit/-webkit-line-clamp/</a></p>
<pre><code><span class="class">.text-overflow-ellipsis</span> <span class="rules">{
    <span class="rule">// 显示一行
    <span class="attribute">-webkit-line-clamp</span>:<span class="value"> <span class="number">1</span></span></span>;
    <span class="rule">// 溢出隐藏
    <span class="attribute">text-overflow</span>:<span class="value"> ellipsis</span></span>;
    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;
    <span class="rule">// 和模型的子元素垂直排列
    <span class="attribute">display</span>:<span class="value"> -webkit-box</span></span>;
    <span class="rule"><span class="attribute">-webkit-box-orient</span>:<span class="value"> vertical</span></span>;

<span class="rule">}</span></span>
</code></pre><ul>
<li><p>::-webkit-input-placeholder 设置占位文字的样式<br><a href="http://css-tricks.com/snippets/css/style-placeholder-text/" target="_blank" rel="external">http://css-tricks.com/snippets/css/style-placeholder-text/</a> </p>
<p> .selector::-webkit-input-placeholder {</p>
<pre><code> <span class="attribute">color</span><span class="value">: <span class="hexcolor">#eee</span>;</span>
</code></pre><p> }</p>
</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<ul>
<li><a href="http://ued.ctrip.com/blog/wp-content/webkitcss/index.html" target="_blank" rel="external">携程CSS3-webkit-私有属性列表</a></li>
</ul>
]]></content>
    
    
      <category term="css3" scheme="http://laispace.github.io/tags/css3/"/>
    
      <category term="CSS" scheme="http://laispace.github.io/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阻止元素被选中及清除选中的方法]]></title>
    <link href="http://laispace.github.io/2014/08/%E9%98%BB%E6%AD%A2%E5%85%83%E7%B4%A0%E8%A2%AB%E9%80%89%E4%B8%AD%E5%8F%8A%E6%B8%85%E9%99%A4%E9%80%89%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://laispace.github.io/2014/08/阻止元素被选中及清除选中的方法/</id>
    <published>2014-08-12T09:42:54.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>有时候，我们希望阻止用户选中我们指定区域的文字或内容。</p>
<p>举个栗子，有时候用户在一个区域执行频繁的点击操作，一不小心傲娇地点多了，就会选中当前区域的内容。</p>
<p>再举个栗子，制作轮播组件的时候，点击下一页，若点击的快的话，浏览器会识别为双击。</p>
<p>双击的默认效果是选中整片区域，这时候轮播图组件就会被表示忧郁的蓝色幕布盖住，多忧桑啊~</p>
<p><img src="http://laispace.u.qiniudn.com/%E9%98%BB%E6%AD%A2%E5%85%83%E7%B4%A0%E8%A2%AB%E9%80%89%E4%B8%AD%E5%8F%8A%E6%B8%85%E9%99%A4%E9%80%89%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%951.jpg" alt=""></p>
<p>你看，这妹子多赞啊，可是你一紧张就乱点下一张的话，就变成酱紫了：</p>
<p><img src="http://laispace.u.qiniudn.com/%E9%98%BB%E6%AD%A2%E5%85%83%E7%B4%A0%E8%A2%AB%E9%80%89%E4%B8%AD%E5%8F%8A%E6%B8%85%E9%99%A4%E9%80%89%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%952.jpg" alt=""></p>
<p>不过别怕，给这个现代化浏览器说好了咱不要这种忧桑色调就可以了：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class">.pretty-girl</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">-webkit-user-select</span>:<span class="value"> none</span></span>;     </div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<p>可是！可是！不是每个浏览器都可以不忧桑！！！那就只能请脚本大王出山了。</p>
<h1 id="阻止选中">阻止选中</h1>
<p>有时候，我们需要禁止用户选中一些文本区域，这时候可以直接通过让 onselectstart 事件 return false 来实现。</p>
<h2 id="使用_JS_阻止整个网页的内容被选中">使用 JS 阻止整个网页的内容被选中</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 或</span></div><div class="line"><span class="built_in">document</span>.body.onmousedown = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ </div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="阻止特定区域的内容被选中">阻止特定区域的内容被选中</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'elemId'</span>);</div><div class="line">elem.onselectstart = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="使用_CSS_控制样式阻止内容被选中">使用 CSS 控制样式阻止内容被选中</h2>
<p>仅支持非 IE10 以下的浏览器。IE9 以下请使用 onselectstart=”return false;” 的方式来实现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class">.unselect</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">-webkit-user-select</span>:<span class="value"> none</span></span>; </div><div class="line">    <span class="rule"><span class="attribute">-moz-user-select</span>:<span class="value"> none</span></span>;    </div><div class="line">    <span class="rule"><span class="attribute">-khtml-user-select</span>:<span class="value"> none</span></span>;  </div><div class="line">    <span class="rule"><span class="attribute">-ms-user-select</span>:<span class="value"> none</span></span>;    </div><div class="line">    </div><div class="line">    <span class="comment">/* 以下两个属性目前并未支持，写在这里为了减少风险 */</span></div><div class="line">    <span class="rule"><span class="attribute">-o-user-select</span>:<span class="value"> none</span></span>;</div><div class="line">    <span class="rule"><span class="attribute">user-select</span>:<span class="value"> none</span></span>;  </div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<p>user-select: auto;  =&gt; 用户可以选中元素中的内容</p>
<p>user-select: none; =&gt; 用户不可选中元素中的内容</p>
<p>user-select: text;  =&gt; 用户可以选中元素中的文字</p>
<p>目前这个 user-select 兼容 Chrome 6+、Firefox、IE 10+、Opera 15+、Safari 3.1+。</p>
<p>需要注意的是，这个 user-select 还带浏览器厂商前缀，意味着她们还是非标准的，将来可能会改变。在生产环境中要慎用。</p>
<h1 id="清除选中">清除选中</h1>
<p>有时候用户选中文字进行复制后，我们使用手动的方式进行选中的清除。</p>
<h2 id="使用_JS_清除选中">使用 JS 清除选中</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearSelections</span> <span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.getSelector) {</div><div class="line">        <span class="comment">// 获取选中</span></div><div class="line">        <span class="keyword">var</span> selection = <span class="built_in">window</span>.getSelection();</div><div class="line">        <span class="comment">// 清除选中</span></div><div class="line">        selection.removeAllRanges();</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.selection && <span class="built_in">document</span>.selection.empty) {</div><div class="line">       <span class="comment">// 兼容 IE8 以下，但 IE9+ 以上同样可用</span></div><div class="line">        <span class="built_in">document</span>.selection.empty();</div><div class="line">        <span class="comment">// 或使用 clear() 方法</span></div><div class="line">        <span class="comment">// document.selection.clear();</span></div><div class="line">    }       </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="使用_CSS_清除选中">使用 CSS 清除选中</h2>
<p>不考虑低版本 IE 的情况下，我们简单给选中元素添加以上 .unselect 的样式即可。</p>
<h3 id="参考链接">参考链接</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/user-select" target="_blank" rel="external">MDN user-select</a></p>
]]></content>
    
    
      <category term="clearSelect" scheme="http://laispace.github.io/tags/clearSelect/"/>
    
      <category term="Javascript" scheme="http://laispace.github.io/categories/Javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[【译】HTML5 prefetch]]></title>
    <link href="http://laispace.github.io/2014/08/%E3%80%90%E8%AF%91%E3%80%91HTML5-prefetch/"/>
    <id>http://laispace.github.io/2014/08/【译】HTML5-prefetch/</id>
    <published>2014-08-11T10:45:45.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>声明：此文带着自己的理解，不完全按原文翻译，<a href="https://medium.com/@luisvieira_gmr/html5-prefetch-1e54f6dda15d" target="_blank" rel="external">原文地址</a></p>
</blockquote>
<p>prefetch 即预加载，在用户需要前我们就将所需的资源加载完毕。</p>
<h1 id="有了浏览器缓存，为何还需要预加载？">有了浏览器缓存，为何还需要预加载？</h1>
<ul>
<li>用户可能是第一次访问网站，此时还无缓存</li>
<li>用户可能清空了缓存</li>
<li>缓存可能已经过期，资源将重新加载</li>
<li>用户访问的缓存文件可能不是最新的，需要重新加载</li>
</ul>
<h1 id="Chrome_的预加载技术">Chrome 的预加载技术</h1>
<p>现在的 chrome 聪明到根据你的浏览记录，预测到你可能访问或搜索哪些网站，在你打开网站之前就加载好了一些资源了。<br>举个栗子，当你在搜索框输入 “amaz” 时，它猜测到你可能要访问 amazon.com，可能就帮你加载了这个网站的一些资源。<br>如果这个预测算法精准的话，就能大大地提高用户的浏览体验了。</p>
<h1 id="DNS_prefetch">DNS prefetch</h1>
<p>我们知道，当我们访问一个网站如 www.amazon.com 时，需要将这个域名先转化为对应的 IP 地址，这是一个非常耗时的过程。</p>
<p>DNS prefetch 分析这个页面需要的资源所在的域名，浏览器空闲时提前将这些域名转化为 IP 地址，真正请求资源时就避免了上述这个过程的时间。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">'x-dns-prefetch-control'</span> <span class="attribute">content</span>=<span class="value">'on'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'dns-prefetch'</span> <span class="attribute">href</span>=<span class="value">'http://g-ecx.images-amazon.com'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'dns-prefetch'</span> <span class="attribute">href</span>=<span class="value">'http://z-ecx.images-amazon.com'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'dns-prefetch'</span> <span class="attribute">href</span>=<span class="value">'http://ecx.images-amazon.com'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'dns-prefetch'</span> <span class="attribute">href</span>=<span class="value">'http://completion.amazon.com'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'dns-prefetch'</span> <span class="attribute">href</span>=<span class="value">'http://fls-na.amazon.com'</span>&gt;</span></div></pre></td></tr></table></figure>

<p>应用场景1：我们的资源存在在不同的 CDN 中，那提前声明好这些资源的域名，就可以节省请求发生时产生的域名解析的时间。<br>应用场景2：如果我们知道用户接下来的操作一定会发起一起资源的请求，那就可以将这个资源进行 DNS-Prefetch，加强用户体验。</p>
<h1 id="Resource_prefetch">Resource prefetch</h1>
<p>在 Chrome 下，我们可以用 link标签声明特定文件的预加载：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'subresource'</span> <span class="attribute">href</span>=<span class="value">'critical.js'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'subresource'</span> <span class="attribute">href</span>=<span class="value">'main.css'</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">'prefetch'</span> <span class="attribute">href</span>=<span class="value">'secondary.js'</span>&gt;</span></div></pre></td></tr></table></figure>

<p>在 Firefox 中或用 meta 标签声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="variable">http-equiv=</span><span class="string">"Link"</span> <span class="variable">content=</span><span class="string">"&lt;critical.js&gt;; rel=prefetch"</span>&gt;</div></pre></td></tr></table></figure>

<p>rel=’subresource’ 表示当前页面必须加载的资源，应该放到页面最顶端先加载，有最高的优先级。</p>
<p>rel=’prefetch’ 表示当 subresource 所有资源都加载完后，开始预加载这里指定的资源，有最低的优先级。</p>
<p>注意：只有可缓存的资源才进行预加载，否则浪费资源！</p>
<h1 id="Pre_render">Pre render</h1>
<p>前面说到的预解析DNS、预加载资源已经够强悍了有木有，可还有更厉害的预渲染（Pre-rendering）！</p>
<p>预渲染意味着我们提前加载好用户即将访问的下一个页面，否则进行预渲染这个页面将浪费资源，慎用！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link rel='prerender' href='http:<span class="comment">//www.pagetoprerender.com'&gt;</span></div></pre></td></tr></table></figure>

<p>rel=’prerender’ 表示浏览器会帮我们渲染但隐藏指定的页面，一旦我们访问这个页面，则秒开了！</p>
<p>在 Firefox 中或用 rel=’next’ 来声明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;link <span class="variable">rel=</span><span class="string">"next"</span> <span class="variable">href=</span><span class="string">"http://www.pagetoprerender.com"</span>&gt;</div></pre></td></tr></table></figure>

<h1 id="不是所有的资源都可以预加载">不是所有的资源都可以预加载</h1>
<p>当资源为以下列表中的资源时，将阻止预渲染操作：</p>
<ul>
<li>URL 中包含下载资源</li>
<li>页面中包含音频、视频</li>
<li>POST、PUT 和 DELETE 操作的 ajax 请求</li>
<li>HTTP 认证(Authentication)</li>
<li>HTTPS 页面</li>
<li>含恶意软件的页面</li>
<li>弹窗页面</li>
<li>占用资源很多的页面</li>
<li>打开了 chrome developer tools 开发工具</li>
</ul>
<h1 id="手动触发预渲染操作">手动触发预渲染操作</h1>
<p>在 head 中强势插入 link[rel=’prerender’] 即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">hint</span> =document.createElement(<span class="string">"link"</span>)</div><div class="line"><span class="keyword">hint</span>.setAttribute(“rel”,”prerender”)</div><div class="line"><span class="keyword">hint</span>.setAttribute(“href”,”next-page.html”)</div><div class="line">document.getElementsByTagName(“head”)[<span class="number">0</span>].appendChild(<span class="keyword">hint</span>)</div></pre></td></tr></table></figure>

<h1 id="兼容性">兼容性</h1>
<p>这么好用的特性，当然要考虑各浏览器的兼容程度了(哭：</p>
<p>IE9 支持 DNS pre-fetching 但管它叫 prefetch。</p>
<p>IE10+ 中 dns-prefetch 和 prefetch 是等价的。</p>
<p>其他方面的测试，目前还没有很好的方案，暂且只能通过查看浏览器是否缓存来测试。 </p>
<p>在 Chrome 中打开了 chrome developer tools 开发工具会阻止页面的预渲染，所以我们看不到这个过程，但可以在 chrome://cache/ 或 chrome://net-internals/#prerender 中查看。</p>
<p>Firefox 可以在 about:cache 中查看。</p>
<h1 id="警告">警告</h1>
<blockquote>
<p>这些特定还是实验性质的，将来可能改变。</p>
<p>权利越大，责任越大，不要滥用！</p>
</blockquote>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><p><a href="https://medium.com/@luisvieira_gmr/html5-prefetch-1e54f6dda15d" target="_blank" rel="external">html5-prefetch</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Controlling_DNS_prefetching" target="_blank" rel="external">MDN Controlling DNS prefetching</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="external">MDN Link prefetching FAQ</a></p>
</li>
</ul>
]]></content>
    
    
      <category term="html5" scheme="http://laispace.github.io/tags/html5/"/>
    
      <category term="prefetch" scheme="http://laispace.github.io/tags/prefetch/"/>
    
      <category term="Translate" scheme="http://laispace.github.io/categories/Translate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git fork 别人的项目后更新代码的方法]]></title>
    <link href="http://laispace.github.io/2014/08/Git-fork-%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://laispace.github.io/2014/08/Git-fork-别人的项目后更新代码的方法/</id>
    <published>2014-08-02T11:19:40.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>举个例子，需要 fork 这个项目 <a href="https://github.com/tarobjtu/WebFundamentals.git" target="_blank" rel="external">https://github.com/tarobjtu/WebFundamentals.git</a></p>
</li>
<li><p>点击 fork, 就会复制一份代码到自己的 repo <a href="https://github.com/laispace/WebFundamentals.git" target="_blank" rel="external">https://github.com/laispace/WebFundamentals.git</a></p>
</li>
<li><p>本地 clone 自己 repo 中的这个项目</p>
<p> $ git clone <a href="https://github.com/laispace/WebFundamentals.git" target="_blank" rel="external">https://github.com/laispace/WebFundamentals.git</a></p>
</li>
<li><p>添加自己的远程仓库</p>
<p> $ cd WebFundamentals<br> $ git remote add laispace <a href="https://github.com/laispace/WebFundamentals.git" target="_blank" rel="external">https://github.com/laispace/WebFundamentals.git</a></p>
</li>
<li><p>修改代码后进行 push</p>
<p> $ git add —all<br> $ git commit -m ‘edit some files’<br> $ git push</p>
</li>
</ol>
<p>这时候，如果源仓库 tarobjtu 的项目代码进行了更新，而我们自己 fork 下来的代码想要合并这些更新怎么做呢？</p>
<ol>
<li><p>添加源项目的远程仓库</p>
<p> $ git remote add tarobjtu <a href="https://github.com/tarobjtu/WebFundamentals.git" target="_blank" rel="external">https://github.com/tarobjtu/WebFundamentals.git</a><br> // 这时候可以看到有两个源了<br> $ git remote<br> // laispace<br> // tarobjtu</p>
</li>
<li><p>拉取源仓库的代码到本地</p>
<p> $ git fetch tarobjtu</p>
</li>
<li><p>合并源仓库的 master 分支代码到本地</p>
<p> $ git merge tarobjtu/master</p>
</li>
<li><p>提交代码到我们自己的仓库</p>
<p> $ git add —all<br> $ git commit -m ‘合并源仓库代码’<br> $ git push</p>
</li>
</ol>
]]></content>
    
    
      <category term="git" scheme="http://laispace.github.io/tags/git/"/>
    
      <category term="Tools" scheme="http://laispace.github.io/categories/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Base 64 编码]]></title>
    <link href="http://laispace.github.io/2014/07/Base-64-%E7%BC%96%E7%A0%81/"/>
    <id>http://laispace.github.io/2014/07/Base-64-编码/</id>
    <published>2014-07-27T20:23:26.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>在浏览器中，使用 window.btoa() 将字符串或二进制值转化为 Base64 编码，使用 window.atob() 还原。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.btoa(<span class="string">'laispace'</span>); <span class="regexp">//</span><span class="function">=&gt;</span> <span class="string">"bGFpc3BhY2U="</span></div><div class="line"><span class="built_in">window</span>.atob(<span class="string">"bGFpc3BhY2U="</span>); <span class="regexp">//</span><span class="function">=&gt;</span><span class="string">"laispace"</span></div></pre></td></tr></table></figure>

<p>注意，要将非 ASCII 编码字符转化为 Base64 编码的话，需要先进行转码，否则会报错</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.btoa(encodeURI(<span class="string">'赖小赖'</span>)); <span class="regexp">//</span>=&gt; <span class="string">"JUU4JUI1JTk2JUU1JUIwJThGJUU4JUI1JTk2"</span></div><div class="line">window.atob(<span class="string">'JUU4JUI1JTk2JUU1JUIwJThGJUU4JUI1JTk2'</span>); <span class="regexp">//</span>=&gt; <span class="string">"<span class="variable">%E8</span><span class="variable">%B5</span><span class="variable">%96</span><span class="variable">%E5</span><span class="variable">%B0</span><span class="variable">%8F</span><span class="variable">%E8</span><span class="variable">%B5</span><span class="variable">%96</span>"</span></div><div class="line">decodeURI(<span class="string">"<span class="variable">%E8</span><span class="variable">%B5</span><span class="variable">%96</span><span class="variable">%E5</span><span class="variable">%B0</span><span class="variable">%8F</span><span class="variable">%E8</span><span class="variable">%B5</span><span class="variable">%96</span>"</span>); <span class="regexp">//</span>=&gt; <span class="string">"赖小赖"</span></div></pre></td></tr></table></figure>

]]></content>
    
    
      <category term="base64" scheme="http://laispace.github.io/tags/base64/"/>
    
      <category term="Javascript" scheme="http://laispace.github.io/categories/Javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 CSS3 实现模糊效果]]></title>
    <link href="http://laispace.github.io/2014/07/%E4%BD%BF%E7%94%A8CSS3%E7%9A%84filter%E5%B1%9E%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/"/>
    <id>http://laispace.github.io/2014/07/使用CSS3的filter属性实现模糊效果/</id>
    <published>2014-07-25T11:06:19.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>使用一个filter属性就可以实现很赞的模糊效果。</p>
<pre><code><span class="attribute">filter</span><span class="value">: <span class="function">blur</span>(<span class="number">3px</span>);</span>
</code></pre><p>这在制作一些弹出框的背景效果时非常有用，加以动画效果则更佳：）</p>
<a id="more"></a>

<iframe width="100%" height="600" src="http://jsfiddle.net/laiqs2011/BKdzX/2/embedded/result,html,css,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>]]></content>
    <summary type="html"><![CDATA[<p>使用一个filter属性就可以实现很赞的模糊效果。</p>
<pre><code><span class="attribute">filter</span><span class="value">: <span class="function">blur</span>(<span class="number">3px</span>);</span>
</code></pre><p>这在制作一些弹出框的背景效果时非常有用，加以动画效果则更佳：）</p>
]]></summary>
    
      <category term="filter" scheme="http://laispace.github.io/tags/filter/"/>
    
      <category term="blur" scheme="http://laispace.github.io/tags/blur/"/>
    
      <category term="CSS" scheme="http://laispace.github.io/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[meta viewport 标签]]></title>
    <link href="http://laispace.github.io/2014/07/meta-viewport-%E6%A0%87%E7%AD%BE/"/>
    <id>http://laispace.github.io/2014/07/meta-viewport-标签/</id>
    <published>2014-07-25T09:05:42.000Z</published>
    <updated>2014-12-18T13:21:38.000Z</updated>
    <content type="html"><![CDATA[<p>viewport 可以控制页面的原始宽度，限制用户的缩放行为。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"viewport"</span> <span class="variable">content=</span><span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"</span> /&gt;</div></pre></td></tr></table></figure>

<p>width: 控制 viewport 的宽度，可指定为数字如 800，或特殊值如 device-width，即设置为 100%。</p>
<p>height: 控制 viewport 的高度。</p>
<p>initial-scale: 页面第一次加载时的缩放比例。</p>
<p>maximum-scale: 最大缩放比例，取值从 0 到 10。</p>
<p>minimum-scale: 最小缩放比例，取值从 0 到 10。</p>
<p>user-scaleble: 是否允许用户缩放，取值为 yes/true 或 no/false。</p>
<a id="more"></a>

<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank" rel="external">Using the viewport meta tag to control layout on mobile browsers</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>viewport 可以控制页面的原始宽度，限制用户的缩放行为。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta <span class="variable">name=</span><span class="string">"viewport"</span> <span class="variable">content=</span><span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"</span> /&gt;</div></pre></td></tr></table></figure>

<p>width: 控制 viewport 的宽度，可指定为数字如 800，或特殊值如 device-width，即设置为 100%。</p>
<p>height: 控制 viewport 的高度。</p>
<p>initial-scale: 页面第一次加载时的缩放比例。</p>
<p>maximum-scale: 最大缩放比例，取值从 0 到 10。</p>
<p>minimum-scale: 最小缩放比例，取值从 0 到 10。</p>
<p>user-scaleble: 是否允许用户缩放，取值为 yes/true 或 no/false。</p>
]]></summary>
    
      <category term="meta" scheme="http://laispace.github.io/tags/meta/"/>
    
      <category term="viewport" scheme="http://laispace.github.io/tags/viewport/"/>
    
      <category term="HTML" scheme="http://laispace.github.io/categories/HTML/"/>
    
  </entry>
  
</feed>
